/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
int sub_8048FC0();
// int dup2(int fd, int fd2);
// int strcmp(const char *s1, const char *s2);
// int __cdecl open64(_DWORD, _DWORD); weak
// int putc_unlocked(int c, FILE *stream);
// int printf(const char *format, ...);
// int fflush(FILE *stream);
// void _exit(int status);
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// char *strdup(const char *s);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// int ferror(FILE *stream);
// int fclose(FILE *stream);
// intmax_t strtoimax(const char *nptr, char **endptr, int base);
// int memcmp(const void *s1, const void *s2, size_t n);
// int iswprint(wint_t wc);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// size_t __ctype_get_mb_cur_max(void);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// size_t __fpending(FILE *fp);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD); weak
// void error(int status, int errnum, const char *format, ...);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// void *malloc(size_t size);
// int re_match(struct re_pattern_buffer *buffer, const char *string, int length, int start, struct re_registers *regs);
// int __freading(FILE *fp);
// int iswspace(wint_t wc);
// void exit(int status);
// int __cdecl ftello64(_DWORD); weak
// char *gettext(const char *msgid);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// size_t iconv(iconv_t cd, char **inbuf, size_t *inbytesleft, char **outbuf, size_t *outbytesleft);
// int iconv_close(iconv_t cd);
// int fprintf(FILE *stream, const char *format, ...);
// int re_search(struct re_pattern_buffer *buffer, const char *string, int length, int start, int range, struct re_registers *regs);
// int re_compile_fastmap(struct re_pattern_buffer *buffer);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// void *memchr(const void *s, int c, size_t n);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// int strnlen(void); weak
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int toupper(int c);
// int sprintf(char *s, const char *format, ...);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// const char *re_compile_pattern(const char *pattern, size_t length, struct re_pattern_buffer *buffer);
// int strncmp(const char *s1, const char *s2, size_t n);
// void abort(void);
// iconv_t iconv_open(const char *tocode, const char *fromcode);
// int close(int fd);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// int putchar_unlocked(int c);
// int _gmon_start__(void); weak
void sub_8049533();
void sub_8049550();
int sub_8049560();
int sub_80495D0();
int sub_80495F0();
void sub_804964F();
void sub_804966A();
int sub_804967A();
void sub_804975C();
void sub_8049777();
signed int sub_8049787();
void sub_8049869();
void sub_8049884();
int sub_8049894();
void sub_8049976();
void sub_8049991();
int sub_80499A1();
int sub_8049A2B();
void sub_8049A9F();
void sub_8049ABA();
int __fastcall sub_8049ACA(int a1, int a2);
void sub_8049BDA();
void sub_8049BF5();
int sub_8049C05();
void sub_8049D03();
void sub_8049D1E();
int sub_8049D2E();
int __cdecl sub_8049DDE(unsigned __int8 a1);
int sub_8049DF0();
int sub_8049E1B();
int __cdecl sub_8049E46(char *s1); // idb
char *__cdecl sub_8049FEC(char *a1);
char *__cdecl sub_804A01C(char *s);
int __cdecl sub_804A387(int a1);
char sub_804A49B();
int __cdecl sub_804A603(char *s1, int); // idb
int sub_804A716(const void *, const void *); // idb
int compar(const void *, const void *); // idb
int __cdecl sub_804A8C3(void *, int); // idb
void sub_804A96D();
int __cdecl sub_804A9A6(char *s1); // idb
void __cdecl sub_804AA4E(char *s1, int a2);
int __cdecl sub_804B2B1(int a1);
_DWORD __cdecl sub_804B2D7(_DWORD, _DWORD); // weak
_DWORD __cdecl sub_804BAAA(_DWORD); // weak
int sub_804C685(void); // weak
int sub_804C8A8(void); // weak
int sub_804CB70(void); // weak
size_t sub_804CFBE();
void __cdecl __noreturn sub_804D063(int status); // idb
// void __usercall __noreturn main(int a1@<edx>, int a2@<ecx>, int argc, char **argv);
void __noreturn sub_804DC01();
int __cdecl sub_804DC15(char *s, int, int, size_t); // idb
void __cdecl sub_804DD40(int a1, int a2, int a3);
_DWORD __cdecl sub_804DDC3(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_804DEFF(int, char *s, int, int, size_t, int); // idb
signed int __cdecl sub_804E186(int a1);
int __cdecl sub_804E1D5(int, int, FILE *stream); // idb
void __fastcall __noreturn sub_804E361(int a1, int a2, int a3);
int __cdecl sub_804E3B0(int c, size_t n); // idb
int __cdecl sub_804E453(_DWORD, _DWORD); // weak
void __cdecl __noreturn sub_804E485(int a1, int a2, const char *a3);
int __cdecl sub_804EA69(char *msgid, char *); // idb
int __cdecl sub_804EDBD(int *a1, unsigned __int8 a2, char a3);
int *__cdecl sub_804EE87(int *a1, int a2, int a3);
// _DWORD *__userpurge sub_804EEC8@<eax>(_DWORD *a1, int a2);
int __cdecl sub_804EF8A(char *msgid, int); // idb
int __cdecl sub_804F03E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
// int __usercall sub_804F063@<eax>(char *a1@<ebx>, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11);
int sub_804FE10(); // weak
_DWORD __cdecl sub_8050122(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_80503F5(int a1, int a2);
int __cdecl sub_80504AA(int a1, int a2, int a3);
int __cdecl sub_80504E8(int a1, int a2, int a3, int a4);
int __cdecl sub_8050580(int a1, int a2, unsigned __int8 a3);
int __cdecl sub_805064A(int a1, unsigned __int8 a2);
int __cdecl sub_8050683(int a1);
int __cdecl sub_80506C0(int a1, int a2, int a3);
int sub_8050781();
int sub_80507D1();
int __cdecl sub_8050940(int a1, int a2, int a3);
int __cdecl sub_805099B(int a1, int a2);
int __cdecl sub_80509BD(int a1);
char *__cdecl sub_80509D8(FILE *stream, int a2);
char *__cdecl sub_8050C78(int a1, int a2, int a3);
char *__cdecl sub_8050CFF(int a1, int a2);
int __cdecl __noreturn sub_8050D43(const char *a1, int a2);
int sub_80510F9(); // weak
int __cdecl sub_80510FF(FILE *stream, int, int, int, int, int); // idb
int __cdecl sub_80518A1(FILE *stream, int, int, int, int); // idb
int sub_8051917(FILE *stream, int a2, int a3, int a4, ...);
void *__cdecl sub_80519C7(unsigned int a1, unsigned int a2);
void *__cdecl sub_8051A2A(void *ptr, int a2, int a3);
void *__cdecl sub_8051AC1(size_t size);
void *__cdecl sub_8051AD4(size_t size);
void *__cdecl sub_8051AFE(void *ptr, size_t size);
void *__cdecl sub_8051BD6(void *src, size_t n);
void __noreturn sub_8051C24();
int __cdecl sub_8051D19(char *s, char *fromcode, char *tocode); // idb
_DWORD __cdecl sub_8051D70(_DWORD, _DWORD); // weak
int __cdecl sub_8051E8F(int a1, int a2, int a3);
int __cdecl sub_8051EC5(char *nptr, int, int base, int, char *s); // idb
int __cdecl sub_805232A(FILE *stream); // idb
int __cdecl sub_80523ED(_DWORD *a1);
int __cdecl sub_8052426(FILE *fp); // idb
_DWORD __cdecl sub_8052494(_DWORD, _DWORD, _DWORD); // weak
size_t __cdecl sub_80525B3(wchar_t *pwc, char *s, size_t n, mbstate_t *p);
int __cdecl sub_805263E(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_80526B8(FILE *fp); // idb
int __cdecl sub_8052739(int category); // idb
void *sub_80527B0();
const char *sub_8052CF8();
_DWORD __cdecl sub_8052DAB(_DWORD); // weak
int __cdecl sub_8052E67(char *file, unsigned int line, char *function); // idb
int __cdecl sub_8053161(int a1, int a2, unsigned int a3);
void __cdecl __noreturn sub_80533D9(int a1, const char *a2, int a3);
// _BYTE *__usercall sub_8053BCF@<eax>(int a1@<ebx>, _BYTE *a2, _BYTE *a3);
// int __usercall sub_8054459@<eax>(int a1@<edx>, int a2@<ecx>, int a3);
int __cdecl sub_80547CC(char **inbuf, size_t *inbytesleft, char **outbuf, size_t *outbytesleft); // idb
void *__cdecl sub_8054BE4(char *s, iconv_t cd);
int __cdecl sub_8054F1D(char *s, char *fromcode, char *tocode); // idb
size_t __cdecl sub_805501E(void *s, size_t n);
int __cdecl sub_8055279(int a1);
unsigned int __cdecl sub_80552AF(unsigned int a1);
bool __cdecl sub_8055516(unsigned __int8 a1);
int __cdecl __noreturn sub_805557D(const char *a1);
int sub_805567F(); // weak
_DWORD __cdecl sub_805568B(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_80558D5(int a1);
int __cdecl sub_8055904(int a1, int a2);
int __fastcall sub_8055A8A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_8055AF8(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_8055B70(_DWORD, _DWORD); // weak
int __stdcall sub_8055BDC(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (**sub_8055BF0())();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN locret_8049AD9; // weak
_UNKNOWN loc_804A170; // weak
_UNKNOWN loc_804A207; // weak
_UNKNOWN loc_804A22A; // weak
_UNKNOWN loc_804A25D; // weak
_UNKNOWN loc_804A44E; // weak
_UNKNOWN loc_804A48A; // weak
_UNKNOWN loc_804E386; // weak
_UNKNOWN loc_804F1F2; // weak
_UNKNOWN loc_804F271; // weak
_UNKNOWN loc_804F30F; // weak
_UNKNOWN loc_804F314; // weak
_UNKNOWN loc_804F453; // weak
_UNKNOWN loc_804F5D7; // weak
_UNKNOWN loc_804F5E2; // weak
_UNKNOWN loc_804F915; // weak
_UNKNOWN loc_804F95E; // weak
_UNKNOWN loc_804FA17; // weak
_UNKNOWN loc_804FA54; // weak
_UNKNOWN loc_804FC3B; // weak
_UNKNOWN loc_804FC4C; // weak
_UNKNOWN loc_804FC8E; // weak
_UNKNOWN loc_804FCF7; // weak
_UNKNOWN loc_804FD6A; // weak
_UNKNOWN loc_804FE0B; // weak
_UNKNOWN loc_8050EB2; // weak
_UNKNOWN loc_8050EC6; // weak
_UNKNOWN loc_8050F1C; // weak
_UNKNOWN loc_8050F2B; // weak
_UNKNOWN loc_8050F80; // weak
_UNKNOWN loc_8050F91; // weak
_UNKNOWN loc_8051091; // weak
_UNKNOWN loc_80510F4; // weak
_UNKNOWN loc_805244B; // weak
_UNKNOWN loc_805245A; // weak
_UNKNOWN locret_8052492; // weak
_UNKNOWN loc_8052620; // weak
_UNKNOWN loc_8052639; // weak
_UNKNOWN loc_80526B1; // weak
_UNKNOWN loc_80527A6; // weak
_UNKNOWN loc_80527AA; // weak
_UNKNOWN loc_805297D; // weak
_UNKNOWN loc_805298C; // weak
_UNKNOWN loc_8053214; // weak
_UNKNOWN loc_805321E; // weak
_UNKNOWN loc_8053D93; // weak
_UNKNOWN loc_8053D9D; // weak
_UNKNOWN loc_8054236; // weak
_UNKNOWN loc_805433F; // weak
_UNKNOWN loc_805434A; // weak
_UNKNOWN loc_80543CD; // weak
_UNKNOWN loc_80543D4; // weak
_UNKNOWN loc_8054493; // weak
_UNKNOWN loc_8054498; // weak
_UNKNOWN loc_80555EC; // weak
_UNKNOWN loc_80555FF; // weak
_UNKNOWN loc_8055645; // weak
_UNKNOWN loc_805567A; // weak
char locale = '\0'; // idb
_UNKNOWN unk_8056CC5; // weak
_UNKNOWN unk_8056FF4; // weak
_UNKNOWN unk_80575BF; // weak
int dword_8057780[8] = { 6656, 4294967279, 4294967294, 2147483646, 0, 0, 0, 0 }; // idb
_UNKNOWN unk_80581F0; // weak
_UNKNOWN unk_80581F3; // weak
_UNKNOWN unk_80591FC; // weak
_UNKNOWN unk_80591FF; // weak
int (*off_805AEEC[2])() = { &sub_80495F0, &sub_80495D0 }; // weak
int (*off_805AEF0)() = &sub_80495D0; // weak
int (*dword_805B008)(void) = NULL; // weak
int dword_805B160 = 0; // weak
int dword_805B174 = 0; // weak
int dword_805B188 = 0; // weak
int dword_805B19C = 0; // weak
int dword_805B1CC = 0; // weak
char byte_805B1D0 = '\x01'; // weak
int status = 1; // idb
_UNKNOWN unk_805B228; // weak
_UNKNOWN unk_805B244; // weak
_UNKNOWN unk_805B247; // weak
_UNKNOWN unk_805B258; // weak
_UNKNOWN unk_805B25B; // weak
FILE *stderr; // idb
FILE *stdout; // idb
char byte_805B2AC; // weak
char byte_805B3E0; // weak
char byte_805B4DC; // weak
int dword_805B4DF; // weak
char byte_805B4E3; // weak
char *dword_805B4E7; // idb
int dword_805B4FB; // weak
int dword_805B63B; // weak
char byte_805B77B[256]; // idb
char byte_805B89B; // weak
char byte_805B8A4; // weak
char byte_805B8A5; // weak
char byte_805B8BB; // weak
void *ptr; // idb
size_t nmemb; // idb
int dword_805BB0B; // weak
int dword_805BB0F; // weak
char byte_805BB13; // weak
char *dword_805BB2F; // idb
int dword_805BB33; // weak
char byte_805BB37; // weak
int dword_805BB4B; // weak
int dword_805BB5B; // weak
int dword_805BB5F; // weak
int dword_805BB63; // weak
int dword_805BB67; // weak
int dword_805BB6B; // weak
int dword_805BB6F; // weak
int dword_805BB73; // weak
int dword_805BB77; // weak
int dword_805BB7B; // weak
int dword_805BB7F; // weak
int dword_805BB83; // weak
int dword_805BB87; // weak
int dword_805BC9B; // weak
int dword_805BCBB[262]; // idb
// extern _UNKNOWN __gmon_start__; weak


//----- (08048F98) --------------------------------------------------------
void *init_proc()
{
  void *result; // eax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 80494F0: using guessed type int _gmon_start__(void);

//----- (08048FC0) --------------------------------------------------------
int sub_8048FC0()
{
  return dword_805B008();
}
// 805B008: using guessed type int (*dword_805B008)(void);

//----- (08049500) --------------------------------------------------------
#error "8049503: positive sp value has been found (funcsize=2)"

//----- (08049533) --------------------------------------------------------
void sub_8049533()
{
  ;
}

//----- (08049550) --------------------------------------------------------
void sub_8049550()
{
  ;
}

//----- (08049560) --------------------------------------------------------
int sub_8049560()
{
  int result; // eax

  result = &unk_805B25B - &unk_805B258;
  if ( (unsigned int)(&unk_805B25B - &unk_805B258) > 6 )
    result = 0;
  return result;
}
// 8049560: could not find valid save-restore pair for ebp

//----- (080495D0) --------------------------------------------------------
int sub_80495D0()
{
  int result; // eax

  if ( !byte_805B2AC )
  {
    result = sub_8049560();
    byte_805B2AC = 1;
  }
  return result;
}
// 80495D0: could not find valid save-restore pair for ebp
// 805B2AC: using guessed type char byte_805B2AC;

//----- (080495F0) --------------------------------------------------------
int sub_80495F0()
{
  return 0;
}
// 80495F0: could not find valid save-restore pair for ebp

//----- (0804964F) --------------------------------------------------------
void sub_804964F()
{
  ;
}

//----- (0804966A) --------------------------------------------------------
void sub_804966A()
{
  ;
}

//----- (0804967A) --------------------------------------------------------
int sub_804967A()
{
  int result; // eax

  result = &unk_805B247 - &unk_805B244;
  if ( (unsigned int)(&unk_805B247 - &unk_805B244) > 6 )
    result = 0;
  return result;
}
// 804967A: could not find valid save-restore pair for ebp

//----- (0804975C) --------------------------------------------------------
void sub_804975C()
{
  ;
}

//----- (08049777) --------------------------------------------------------
void sub_8049777()
{
  ;
}

//----- (08049787) --------------------------------------------------------
signed int sub_8049787()
{
  return 3;
}
// 8049787: could not find valid save-restore pair for ebp

//----- (08049869) --------------------------------------------------------
void sub_8049869()
{
  ;
}

//----- (08049884) --------------------------------------------------------
void sub_8049884()
{
  ;
}

//----- (08049894) --------------------------------------------------------
int sub_8049894()
{
  int result; // eax

  result = &unk_805B247 - &unk_805B244;
  if ( (unsigned int)(&unk_805B247 - &unk_805B244) > 6 )
    result = 0;
  return result;
}
// 8049894: could not find valid save-restore pair for ebp

//----- (08049976) --------------------------------------------------------
void sub_8049976()
{
  ;
}

//----- (08049991) --------------------------------------------------------
void sub_8049991()
{
  ;
}

//----- (080499A1) --------------------------------------------------------
int sub_80499A1()
{
  int result; // eax

  result = &unk_805B247 - &unk_805B244;
  if ( (unsigned int)(&unk_805B247 - &unk_805B244) > 6 )
    result = 0;
  return result;
}
// 80499A1: could not find valid save-restore pair for ebp

//----- (08049A2B) --------------------------------------------------------
int sub_8049A2B()
{
  int result; // eax

  result = sub_80499A1();
  byte_805B3E0 = 1;
  return result;
}
// 805B3E0: using guessed type char byte_805B3E0;

//----- (08049A9F) --------------------------------------------------------
void sub_8049A9F()
{
  ;
}

//----- (08049ABA) --------------------------------------------------------
void sub_8049ABA()
{
  ;
}

//----- (08049ACA) --------------------------------------------------------
int __fastcall sub_8049ACA(int a1, int a2)
{
  int result; // eax
  int (__stdcall *v3)(void *, int, int, int, int, int); // eax
  int v4; // [esp+4h] [ebp-18h]
  int v5; // [esp+8h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-10h]
  int v7; // [esp+10h] [ebp-Ch]
  int v8; // [esp+14h] [ebp-8h]
  int v9; // [esp+18h] [ebp-4h]

  result = &unk_80591FF - &unk_80591FC;
  if ( (unsigned int)(&unk_80591FF - &unk_80591FC) > 6 )
  {
    v9 = 0;
    dword_805B174 = (int)&locret_8049AD9;
    v3 = (int (__stdcall *)(void *, int, int, int, int, int))sub_8055B70(a1, a2);
    result = v3(&unk_80591FC, v4, v5, v6, v7, v8);
  }
  return result;
}
// 8055B70: using guessed type int __fastcall sub_8055B70(_DWORD, _DWORD);
// 805B174: using guessed type int dword_805B174;

//----- (08049BDA) --------------------------------------------------------
void sub_8049BDA()
{
  ;
}

//----- (08049BF5) --------------------------------------------------------
void sub_8049BF5()
{
  ;
}

//----- (08049C05) --------------------------------------------------------
int sub_8049C05()
{
  int result; // eax

  result = &unk_80581F3 - &unk_80581F0;
  if ( (unsigned int)(&unk_80581F3 - &unk_80581F0) > 6 )
    result = 0;
  return result;
}
// 8049C05: could not find valid save-restore pair for ebp

//----- (08049D03) --------------------------------------------------------
void sub_8049D03()
{
  ;
}

//----- (08049D1E) --------------------------------------------------------
void sub_8049D1E()
{
  ;
}

//----- (08049D2E) --------------------------------------------------------
int sub_8049D2E()
{
  int result; // eax

  result = &unk_80581F3 - &unk_80581F0;
  if ( (unsigned int)(&unk_80581F3 - &unk_80581F0) > 6 )
    result = 0;
  return result;
}
// 8049D2E: could not find valid save-restore pair for ebp

//----- (08049DDE) --------------------------------------------------------
int __cdecl sub_8049DDE(unsigned __int8 a1)
{
  return a1;
}

//----- (08049DF0) --------------------------------------------------------
int sub_8049DF0()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
  return fputs_unlocked(v1, v0);
}
// 80492B0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (08049E1B) --------------------------------------------------------
int sub_8049E1B()
{
  FILE *v0; // ebx
  char *v1; // eax

  v0 = stdout;
  v1 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n");
  return fputs_unlocked(v1, v0);
}
// 80492B0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (08049E46) --------------------------------------------------------
int __cdecl sub_8049E46(char *s1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // ebx
  char *v5; // eax
  int v7; // [esp-1Ch] [ebp-68h]
  char *v8; // [esp-18h] [ebp-64h]
  char *v9; // [esp-14h] [ebp-60h]
  char *v10; // [esp+0h] [ebp-4Ch]
  char **i; // [esp+4h] [ebp-48h]
  char *v12; // [esp+8h] [ebp-44h]
  const char *v13; // [esp+Ch] [ebp-40h]
  const char *v14; // [esp+10h] [ebp-3Ch]
  const char *v15; // [esp+14h] [ebp-38h]
  const char *v16; // [esp+18h] [ebp-34h]
  const char *v17; // [esp+1Ch] [ebp-30h]
  const char *v18; // [esp+20h] [ebp-2Ch]
  const char *v19; // [esp+24h] [ebp-28h]
  const char *v20; // [esp+28h] [ebp-24h]
  const char *v21; // [esp+2Ch] [ebp-20h]
  const char *v22; // [esp+30h] [ebp-1Ch]
  const char *v23; // [esp+34h] [ebp-18h]
  const char *v24; // [esp+38h] [ebp-14h]
  int v25; // [esp+3Ch] [ebp-10h]
  int v26; // [esp+40h] [ebp-Ch]

  v13 = "[";
  v14 = "test invocation";
  v15 = "coreutils";
  v16 = "Multi-call invocation";
  v17 = "sha224sum";
  v18 = "sha2 utilities";
  v19 = "sha256sum";
  v20 = "sha2 utilities";
  v21 = "sha384sum";
  v22 = "sha2 utilities";
  v23 = "sha512sum";
  v24 = "sha2 utilities";
  v25 = 0;
  v26 = 0;
  v10 = s1;
  for ( i = (char **)(&v7 - 16); *i; i += 2 )
  {
    v8 = *i;
    if ( !strcmp(s1, v8) )
      break;
  }
  if ( i[1] )
    v10 = i[1];
  v1 = gettext("\n%s online help: <%s>\n");
  v9 = "http://www.gnu.org/software/coreutils/";
  v8 = "GNU coreutils";
  printf(v1, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  v12 = setlocale(5, 0);
  if ( v12 && strncmp(v12, "en_", 3u) )
  {
    v2 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
    v8 = s1;
    printf(v2, s1);
  }
  v3 = gettext("Full documentation at: <%s%s>\n");
  v9 = s1;
  v8 = "http://www.gnu.org/software/coreutils/";
  printf(v3, "http://www.gnu.org/software/coreutils/", s1);
  if ( v10 == s1 )
    v4 = " invocation";
  else
    v4 = &locale;
  v5 = gettext("or available locally via: info '(coreutils) %s%s'\n");
  v9 = v4;
  v8 = v10;
  return printf(v5, v10, v4);
}

//----- (08049FEC) --------------------------------------------------------
char *__cdecl sub_8049FEC(char *a1)
{
  char *v1; // ebx
  int *v2; // eax

  v1 = gettext("error in regular expression matcher");
  v2 = __errno_location();
  error(1, *v2, v1);
  return sub_804A01C(a1);
}

//----- (0804A01C) --------------------------------------------------------
#error "804A102: call analysis failed (funcsize=264)"

//----- (0804A387) --------------------------------------------------------
int __cdecl sub_804A387(int a1)
{
  unsigned __int8 *v1; // eax
  size_t v2; // eax
  const char *v3; // eax
  int v4; // edx
  int v5; // ecx
  bool v6; // zf
  void *v7; // eax
  int v8; // ebx
  char *v9; // eax
  const char *v11; // [esp+Ch] [ebp-2Ch]
  int v12; // [esp+10h] [ebp-28h]
  struct re_pattern_buffer *buffer; // [esp+24h] [ebp-14h]
  char *s; // [esp+28h] [ebp-10h]
  const char *v15; // [esp+2Ch] [ebp-Ch]

  buffer = (struct re_pattern_buffer *)(a1 + 4);
  s = *(char **)a1;
  *(_DWORD *)(a1 + 4) = 0;
  buffer->allocated = 0;
  buffer->fastmap = (char *)(a1 + 36);
  if ( byte_805B4E3 )
    v1 = (unsigned __int8 *)byte_805B77B;
  else
    v1 = 0;
  buffer->translate = v1;
  v2 = strlen(s);
  v3 = re_compile_pattern(s, v2, buffer);
  v15 = v3;
  v6 = v3 == 0;
  v7 = &loc_804A44E;
  if ( v6 )
    v7 = &loc_804A48A;
  dword_805B174 = (int)v7;
  sub_8055B70(v5, v4);
  v8 = sub_80509BD((int)s);
  v9 = gettext("%s (for regexp %s)");
  v12 = v8;
  v11 = v15;
  error(1, 0, v9, v15, v8);
  return re_compile_fastmap(buffer);
}
// 8055B70: using guessed type int __fastcall sub_8055B70(_DWORD, _DWORD);
// 805B174: using guessed type int dword_805B174;
// 805B4E3: using guessed type char byte_805B4E3;

//----- (0804A49B) --------------------------------------------------------
char sub_804A49B()
{
  char result; // al
  signed int c; // [esp+1Ch] [ebp-Ch]
  int ca; // [esp+1Ch] [ebp-Ch]

  if ( byte_805B4E3 )
  {
    for ( c = 0; c <= 255; ++c )
      *(_BYTE *)(c + 134592379) = toupper(c);
  }
  if ( dword_805B4FB )
  {
    if ( !*(_BYTE *)dword_805B4FB )
      dword_805B4FB = 0;
  }
  else if ( byte_805B1D0 && byte_805B4DC != 1 )
  {
    dword_805B4FB = (int)"[.?!][]\"')}]*\\($\\|\t\\|  \\)[ \t\n]*";
  }
  else
  {
    dword_805B4FB = (int)"\n";
  }
  if ( dword_805B4FB )
    sub_804A387((int)&dword_805B4FB);
  if ( dword_805B63B )
    return sub_804A387((int)&dword_805B63B);
  result = (char)dword_805B4E7;
  if ( !dword_805B4E7 )
  {
    result = byte_805B1D0;
    if ( byte_805B1D0 )
    {
      for ( ca = 0; ca <= 255; ++ca )
      {
        result = ((*__ctype_b_loc())[ca] & 0x400) != 0;
        *(_BYTE *)(ca + 134592667) = result;
      }
    }
    else
    {
      result = (unsigned int)memset(&byte_805B89B, 1, 0x100u);
      byte_805B8BB = 0;
      byte_805B8A4 = 0;
      byte_805B8A5 = 0;
    }
  }
  return result;
}
// 805B1D0: using guessed type char byte_805B1D0;
// 805B4DC: using guessed type char byte_805B4DC;
// 805B4E3: using guessed type char byte_805B4E3;
// 805B4FB: using guessed type int dword_805B4FB;
// 805B63B: using guessed type int dword_805B63B;
// 805B89B: using guessed type char byte_805B89B;
// 805B8A4: using guessed type char byte_805B8A4;
// 805B8A5: using guessed type char byte_805B8A5;
// 805B8BB: using guessed type char byte_805B8BB;

//----- (0804A603) --------------------------------------------------------
#error "804A644: call analysis failed (funcsize=75)"

//----- (0804A716) --------------------------------------------------------
int __cdecl sub_804A716(const void *a1, const void *a2)
{
  int v2; // eax
  int v3; // ebx
  unsigned __int8 v4; // al
  int result; // eax
  int v6; // ebx
  unsigned __int8 v7; // al
  int i; // [esp+0h] [ebp-10h]
  int j; // [esp+0h] [ebp-10h]
  int v10; // [esp+4h] [ebp-Ch]

  v2 = *((_DWORD *)a1 + 1);
  if ( *((_DWORD *)a2 + 1) <= v2 )
    v2 = *((_DWORD *)a2 + 1);
  v10 = v2;
  if ( byte_805B4E3 )
  {
    for ( i = 0; i < v10; ++i )
    {
      v3 = (unsigned __int8)byte_805B77B[(unsigned __int8)sub_8049DDE(*(_BYTE *)(*(_DWORD *)a1 + i))];
      v4 = sub_8049DDE(*(_BYTE *)(*(_DWORD *)a2 + i));
      if ( v3 != (unsigned __int8)byte_805B77B[v4] )
        return v3 - (unsigned __int8)byte_805B77B[v4];
    }
  }
  else
  {
    for ( j = 0; j < v10; ++j )
    {
      v6 = (unsigned __int8)sub_8049DDE(*(_BYTE *)(*(_DWORD *)a1 + j));
      v7 = sub_8049DDE(*(_BYTE *)(*(_DWORD *)a2 + j));
      if ( v6 != v7 )
        return v6 - v7;
    }
  }
  if ( *((_DWORD *)a1 + 1) < *((_DWORD *)a2 + 1) )
    result = -1;
  else
    result = *((_DWORD *)a1 + 1) > *((_DWORD *)a2 + 1);
  return result;
}
// 805B4E3: using guessed type char byte_805B4E3;

//----- (0804A874) --------------------------------------------------------
int __cdecl compar(const void *a1, const void *a2)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_804A716(a1, a2);
  if ( v3 )
    return v3;
  if ( *(_DWORD *)a1 < *(_DWORD *)a2 )
    return -1;
  return *(_DWORD *)a1 > *(_DWORD *)a2;
}

//----- (0804A8C3) --------------------------------------------------------
int __cdecl sub_804A8C3(void *a1, int a2)
{
  int v3; // [esp+8h] [ebp-10h]
  int v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  v3 = 0;
  v4 = *(_DWORD *)(a2 + 8) - 1;
  while ( v3 <= v4 )
  {
    v5 = (v3 + v4) / 2;
    v6 = sub_804A716(a1, (const void *)(8 * v5 + *(_DWORD *)a2));
    if ( v6 >= 0 )
    {
      if ( v6 <= 0 )
        return 1;
      v3 = v5 + 1;
    }
    else
    {
      v4 = v5 - 1;
    }
  }
  return 0;
}

//----- (0804A96D) --------------------------------------------------------
void sub_804A96D()
{
  if ( nmemb )
    qsort(ptr, nmemb, 0x1Cu, compar);
}

//----- (0804A9A6) --------------------------------------------------------
#error "804A9EE: call analysis failed (funcsize=43)"

//----- (0804AA4E) --------------------------------------------------------
void __cdecl sub_804AA4E(char *s1, int a2)
{
  _BYTE *v2; // [esp+10h] [ebp-18h]
  unsigned int v3; // [esp+14h] [ebp-14h]
  int v4; // [esp+18h] [ebp-10h]
  unsigned int v5; // [esp+1Ch] [ebp-Ch]

  sub_804A603(s1, (int)&v4);
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  v2 = (_BYTE *)v4;
  while ( v5 > (unsigned int)v2 )
  {
    v3 = (unsigned int)v2;
    while ( v5 > (unsigned int)v2 && *v2 != 10 )
      ++v2;
    if ( (unsigned int)v2 > v3 )
    {
      if ( *(_DWORD *)(a2 + 8) == *(_DWORD *)(a2 + 4) )
        *(_DWORD *)a2 = sub_8051A2A(*(void **)a2, a2 + 4, 8);
      *(_DWORD *)(8 * *(_DWORD *)(a2 + 8) + *(_DWORD *)a2) = v3;
      *(_DWORD *)(*(_DWORD *)a2 + 8 * (*(_DWORD *)(a2 + 8))++ + 4) = &v2[-v3];
    }
    if ( v5 > (unsigned int)v2 )
      ++v2;
  }
  qsort(*(void **)a2, *(_DWORD *)(a2 + 8), 8u, sub_804A716);
}

//----- (0804AB92) --------------------------------------------------------
#error "804ACB1: call analysis failed (funcsize=532)"

//----- (0804B2B1) --------------------------------------------------------
int __cdecl sub_804B2B1(int a1)
{
  int result; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  result = a1;
  for ( i = a1; i > 0; --i )
    result = putchar_unlocked(32);
  return result;
}

//----- (0804B2D7) --------------------------------------------------------
#error "804B3B3: call analysis failed (funcsize=245)"

//----- (0804B6FA) --------------------------------------------------------
#error "804B7CD: call analysis failed (funcsize=241)"

//----- (0804BAAA) --------------------------------------------------------
#error "804C363: call analysis failed (funcsize=801)"

//----- (0804C685) --------------------------------------------------------
#error "804C84D: call analysis failed (funcsize=116)"

//----- (0804C8A8) --------------------------------------------------------
#error "804CA41: call analysis failed (funcsize=157)"

//----- (0804CB70) --------------------------------------------------------
#error "804CF4E: call analysis failed (funcsize=278)"

//----- (0804CFBE) --------------------------------------------------------
size_t sub_804CFBE()
{
  size_t result; // eax
  int i; // [esp+18h] [ebp-10h]
  char *v2; // [esp+1Ch] [ebp-Ch]

  dword_805BB0B = 0;
  dword_805BB0F = 0;
  byte_805BB13 = 0;
  dword_805BB2F = 0;
  dword_805BB33 = 0;
  byte_805BB37 = 0;
  v2 = (char *)ptr;
  for ( i = 0; ; ++i )
  {
    result = nmemb;
    if ( (signed int)nmemb <= i )
      break;
    sub_804BAAA(v2);
    if ( dword_805B4DF == 2 )
    {
      sub_804C685();
    }
    else if ( (unsigned int)dword_805B4DF < 2 )
    {
      sub_804CB70();
    }
    else if ( dword_805B4DF == 3 )
    {
      sub_804C8A8();
    }
    v2 += 28;
  }
  return result;
}
// 804BAAA: using guessed type _DWORD __cdecl sub_804BAAA(_DWORD);
// 804C685: using guessed type int sub_804C685(void);
// 804C8A8: using guessed type int sub_804C8A8(void);
// 804CB70: using guessed type int sub_804CB70(void);
// 805B4DF: using guessed type int dword_805B4DF;
// 805BB0B: using guessed type int dword_805BB0B;
// 805BB0F: using guessed type int dword_805BB0F;
// 805BB13: using guessed type char byte_805BB13;
// 805BB33: using guessed type int dword_805BB33;
// 805BB37: using guessed type char byte_805BB37;

//----- (0804D063) --------------------------------------------------------
void __cdecl __noreturn sub_804D063(int status)
{
  int v1; // ebx
  char *v2; // eax
  int v3; // esi
  int v4; // ebx
  char *v5; // eax
  FILE *v6; // ebx
  char *v7; // eax
  FILE *v8; // ebx
  char *v9; // eax
  FILE *v10; // ebx
  char *v11; // eax
  FILE *v12; // ebx
  char *v13; // eax
  FILE *v14; // ebx
  char *v15; // eax
  FILE *v16; // ebx
  char *v17; // eax
  FILE *v18; // ebx
  char *v19; // eax
  FILE *v20; // ebx
  char *v21; // eax

  if ( status )
  {
    v1 = dword_805BB4B;
    v2 = gettext("Try '%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = dword_805BB4B;
    v4 = dword_805BB4B;
    v5 = gettext("Usage: %s [OPTION]... [INPUT]...   (without -G)\n  or:  %s -G [OPTION]... [INPUT [OUTPUT]]\n");
    printf(v5, v4, v3);
    v6 = stdout;
    v7 = gettext("Output a permuted index, including context, of the words in the input files.\n");
    fputs_unlocked(v7, v6);
    sub_8049DF0();
    sub_8049E1B();
    v8 = stdout;
    v9 = gettext(
           "  -A, --auto-reference           output automatically generated references\n"
           "  -G, --traditional              behave more like System V 'ptx'\n");
    fputs_unlocked(v9, v8);
    v10 = stdout;
    v11 = gettext(
            "  -F, --flag-truncation=STRING   use STRING for flagging line truncations.\n"
            "                                 The default is '/'\n");
    fputs_unlocked(v11, v10);
    v12 = stdout;
    v13 = gettext(
            "  -M, --macro-name=STRING        macro name to use instead of 'xx'\n"
            "  -O, --format=roff              generate output as roff directives\n"
            "  -R, --right-side-refs          put references at right, not counted in -w\n"
            "  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
            "  -T, --format=tex               generate output as TeX directives\n");
    fputs_unlocked(v13, v12);
    v14 = stdout;
    v15 = gettext(
            "  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n"
            "  -b, --break-file=FILE          word break characters in this FILE\n"
            "  -f, --ignore-case              fold lower case to upper case for sorting\n"
            "  -g, --gap-size=NUMBER          gap size in columns between output fields\n"
            "  -i, --ignore-file=FILE         read ignore word list from FILE\n"
            "  -o, --only-file=FILE           read only word list from this FILE\n");
    fputs_unlocked(v15, v14);
    v16 = stdout;
    v17 = gettext(
            "  -r, --references               first field of each line is a reference\n"
            "  -t, --typeset-mode               - not implemented -\n"
            "  -w, --width=NUMBER             output width in columns, reference excluded\n");
    fputs_unlocked(v17, v16);
    v18 = stdout;
    v19 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v19, v18);
    v20 = stdout;
    v21 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v21, v20);
    sub_8049E46("ptx");
  }
  exit(status);
}
// 80492B0: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 805BB4B: using guessed type int dword_805BB4B;

//----- (0804D1D7) --------------------------------------------------------
void __usercall __noreturn main(int a1@<edx>, int a2@<ecx>, int argc, char **argv)
{
  sub_804E361(a2, a1, (int)*argv);
}

//----- (0804DC01) --------------------------------------------------------
void __noreturn sub_804DC01()
{
  sub_804D063(1);
}

//----- (0804DC15) --------------------------------------------------------
int __cdecl sub_804DC15(char *s, int a2, int a3, size_t a4)
{
  int result; // eax
  char v5; // [esp+13h] [ebp-15h]
  signed int i; // [esp+14h] [ebp-14h]
  signed int v7; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]

  v7 = -1;
  v5 = 0;
  n = strlen(s);
  for ( i = 0; *(_DWORD *)(4 * i + a2); ++i )
  {
    if ( !strncmp(*(const char **)(4 * i + a2), s, n) )
    {
      if ( strlen(*(const char **)(4 * i + a2)) == n )
        return i;
      if ( v7 == -1 )
      {
        v7 = i;
      }
      else if ( !a3 || memcmp((const void *)(a3 + a4 * v7), (const void *)(i * a4 + a3), a4) )
      {
        v5 = 1;
      }
    }
  }
  if ( v5 )
    result = -2;
  else
    result = v7;
  return result;
}

//----- (0804DD40) --------------------------------------------------------
void __cdecl sub_804DD40(int a1, int a2, int a3)
{
  char *v3; // eax
  char *format; // ST2C_4
  int v5; // ebx
  int v6; // eax

  if ( a3 == -1 )
    v3 = gettext("invalid argument %s for %s");
  else
    v3 = gettext("ambiguous argument %s for %s");
  format = v3;
  v5 = sub_805099B(1, a1);
  v6 = sub_80504AA(0, 8, a2);
  error(0, 0, format, v6, v5);
}

//----- (0804DDC3) --------------------------------------------------------
#error "804DE24: call analysis failed (funcsize=67)"

//----- (0804DEFF) --------------------------------------------------------
int __cdecl sub_804DEFF(int a1, char *s, int a3, int a4, size_t a5, int a6)
{
  int v7; // [esp+1Ch] [ebp-Ch]

  v7 = sub_804DC15(s, a3, a4, a5);
  if ( v7 >= 0 )
    return v7;
  sub_804DD40(a1, (int)s, v7);
  sub_804DDC3(a3, a4, a5);
  ((void (*)(void))a6)();
  return -1;
}
// 804DDC3: using guessed type _DWORD __cdecl sub_804DDC3(_DWORD, _DWORD, _DWORD);

//----- (0804E074) --------------------------------------------------------
#error "804E0DA: call analysis failed (funcsize=73)"

//----- (0804E186) --------------------------------------------------------
signed int __cdecl sub_804E186(int a1)
{
  int fd; // [esp+1Ch] [ebp-Ch]

  fd = open64("/dev/null", 0);
  if ( fd == a1 )
    return 1;
  if ( fd >= 0 )
  {
    close(fd);
    *__errno_location() = 9;
  }
  return 0;
}
// 8049000: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (0804E1D5) --------------------------------------------------------
#error "804E214: call analysis failed (funcsize=108)"

//----- (0804E361) --------------------------------------------------------
void __fastcall __noreturn sub_804E361(int a1, int a2, int a3)
{
  int (__cdecl *v3)(int, size_t); // eax

  v3 = (int (__cdecl *)(int, size_t))&loc_804E386;
  if ( a3 )
    v3 = sub_804E3B0;
  dword_805B174 = (int)v3;
  sub_8055B70(a1, a2);
  fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
  abort();
}
// 8055B70: using guessed type int __fastcall sub_8055B70(_DWORD, _DWORD);
// 805B174: using guessed type int dword_805B174;

//----- (0804E3B0) --------------------------------------------------------
#error "804E452: positive sp value has been found (funcsize=0)"

//----- (0804E453) --------------------------------------------------------
#error "804E472: call analysis failed (funcsize=14)"

//----- (0804E485) --------------------------------------------------------
void __cdecl __noreturn sub_804E485(int a1, int a2, const char *a3)
{
  sub_8050D43(a3, 2);
}

//----- (0804EA69) --------------------------------------------------------
#error "804EC28: call analysis failed (funcsize=207)"

//----- (0804EDBD) --------------------------------------------------------
int __cdecl sub_804EDBD(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // eax
  int v4; // ST10_4

  if ( a1 )
    v3 = a1;
  else
    v3 = &dword_805BB5B;
  v4 = ((unsigned int)v3[(a2 >> 5) + 2] >> (a2 & 0x1F)) & 1;
  v3[(a2 >> 5) + 2] ^= (v4 ^ a3 & 1) << (a2 & 0x1F);
  return v4;
}
// 805BB5B: using guessed type int dword_805BB5B;

//----- (0804EE87) --------------------------------------------------------
int *__cdecl sub_804EE87(int *a1, int a2, int a3)
{
  int *result; // eax

  if ( !a1 )
    a1 = &dword_805BB5B;
  *a1 = 10;
  if ( !a2 || !a3 )
    abort();
  a1[10] = a2;
  result = a1;
  a1[11] = a3;
  return result;
}
// 805BB5B: using guessed type int dword_805BB5B;

//----- (0804EEC8) --------------------------------------------------------
_DWORD *__userpurge sub_804EEC8@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-38h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]

  memset(&v3, 0, 0x30u);
  if ( a2 == 10 )
    abort();
  *a1 = a2;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  a1[8] = v11;
  a1[9] = v12;
  a1[10] = v13;
  a1[11] = v14;
  return a1;
}

//----- (0804EF8A) --------------------------------------------------------
#error "804EFBA: call analysis failed (funcsize=22)"

//----- (0804F03E) --------------------------------------------------------
#error "804F050: call analysis failed (funcsize=13)"

//----- (0804F063) --------------------------------------------------------
int __usercall sub_804F063@<eax>(char *a1@<ebx>, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11)
{
  char *v11; // edx
  int v12; // ecx
  size_t v13; // eax
  char *v14; // edx
  bool v15; // zf
  void *v16; // eax
  char *v17; // eax
  void *v18; // eax
  bool v19; // al
  const unsigned __int16 **v20; // eax
  void *v21; // eax
  void *v22; // eax
  char *v23; // eax
  void *v24; // eax
  int v25; // edx
  int v26; // ecx
  void *v27; // eax
  int v28; // eax
  mbstate_t *v29; // edx
  int (*v30)(); // eax
  int result; // eax
  char *v32; // [esp-8h] [ebp-8Ch]
  char *v33; // [esp-4h] [ebp-88h]
  char *s; // [esp+0h] [ebp-84h]
  void *s2; // [esp+4h] [ebp-80h]
  size_t n; // [esp+8h] [ebp-7Ch]
  mbstate_t *p; // [esp+Ch] [ebp-78h]
  int v38; // [esp+10h] [ebp-74h]
  char *v39; // [esp+14h] [ebp-70h]
  int v40; // [esp+18h] [ebp-6Ch]
  size_t v41; // [esp+1Ch] [ebp-68h]
  int v42; // [esp+20h] [ebp-64h]
  int v43; // [esp+24h] [ebp-60h]
  int v44; // [esp+28h] [ebp-5Ch]
  int v45; // [esp+2Ch] [ebp-58h]
  int v46; // [esp+30h] [ebp-54h]
  int v47; // [esp+34h] [ebp-50h]
  int v48; // [esp+38h] [ebp-4Ch]
  int v49; // [esp+3Ch] [ebp-48h]
  int v50; // [esp+40h] [ebp-44h]
  int v51; // [esp+44h] [ebp-40h]
  int v52; // [esp+48h] [ebp-3Ch]
  int v53; // [esp+4Ch] [ebp-38h]
  int v54; // [esp+50h] [ebp-34h]
  int v55; // [esp+54h] [ebp-30h]
  int v56; // [esp+58h] [ebp-2Ch]
  int v57; // [esp+5Ch] [ebp-28h]
  int v58; // [esp+60h] [ebp-24h]
  int v59; // [esp+64h] [ebp-20h]
  int v60; // [esp+68h] [ebp-1Ch]
  int v61; // [esp+6Ch] [ebp-18h]
  int v62; // [esp+70h] [ebp-14h]
  int v63; // [esp+74h] [ebp-10h]
  unsigned int v64; // [esp+78h] [ebp-Ch]
  int v65; // [esp+7Ch] [ebp-8h]
  char *v66; // [esp+80h] [ebp-4h]

  v66 = a1;
  v48 = a3;
  v47 = a5;
  v46 = a9;
  v45 = a10;
  v44 = a11;
  v64 = __readgsdword(0x14u);
  *(&s - 13) = 0;
  *(&s - 12) = 0;
  *(&s - 11) = 0;
  *(&s - 10) = 0;
  *((_BYTE *)&s - 72) = 0;
  *((_BYTE *)&s - 61) = __ctype_get_mb_cur_max() == 1;
  *((_BYTE *)&s - 71) = (v41 & 2) != 0;
  *((_BYTE *)&s - 70) = 0;
  *((_BYTE *)&s - 69) = 0;
  *((_BYTE *)&s - 68) = 1;
  switch ( v40 )
  {
    case 0:
      *((_BYTE *)&s - 71) = 0;
      goto LABEL_28;
    case 1:
      goto LABEL_18;
    case 2:
      goto LABEL_21;
    case 3:
      *((_BYTE *)&s - 72) = 1;
LABEL_18:
      *((_BYTE *)&s - 71) = 1;
      goto LABEL_19;
    case 4:
LABEL_19:
      if ( *((_BYTE *)&s - 71) != 1 )
        *((_BYTE *)&s - 72) = 1;
LABEL_21:
      v40 = 2;
      if ( *((_BYTE *)&s - 71) != 1 )
      {
        if ( *(&s - 13) < (char *)p )
        {
          v11 = *(&s - 19);
          (*(&s - 13))[(_DWORD)v11] = 39;
        }
        ++*(&s - 13);
      }
      *(&s - 11) = "'";
      *(&s - 10) = (char *)1;
      goto LABEL_28;
    case 5:
      goto LABEL_3;
    case 6:
      v40 = 5;
      *((_BYTE *)&s - 71) = 1;
LABEL_3:
      if ( *((_BYTE *)&s - 71) != 1 )
      {
        if ( *(&s - 13) < (char *)p )
        {
          v11 = *(&s - 19);
          (*(&s - 13))[(_DWORD)v11] = 34;
        }
        ++*(&s - 13);
      }
      *((_BYTE *)&s - 72) = 1;
      *(&s - 11) = (char *)&unk_8056CC5;
      *(&s - 10) = (char *)1;
      goto LABEL_28;
    case 7:
      *((_BYTE *)&s - 72) = 1;
      *((_BYTE *)&s - 71) = 0;
      dword_805B174 = (int)&loc_804F271;
      sub_8055B70(v12, v11);
      break;
    case 8:
    case 9:
    case 10:
      break;
    default:
      abort();
      return result;
  }
  if ( v40 != 10 )
  {
    *(&s - 22) = (char *)sub_804EF8A("`", v40);
    *(&s - 23) = (char *)sub_804EF8A("'", v40);
  }
  if ( *((_BYTE *)&s - 71) != 1 )
  {
    *(&s - 11) = *(&s - 22);
    dword_805B188 = (int)&loc_804F1F2;
    sub_8055AF8(s, s2, n, p, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48);
    do
    {
      if ( *(&s - 13) < (char *)p )
        (*(&s - 19))[(_DWORD)*(&s - 13)] = **(&s - 11);
      ++*(&s - 13);
      ++*(&s - 11);
    }
    while ( **(&s - 11) );
  }
  *((_BYTE *)&s - 72) = 1;
  *(&s - 11) = *(&s - 23);
  s = *(&s - 11);
  *(&s - 10) = (char *)strlen(s);
LABEL_28:
  *(&s - 14) = 0;
  while ( 1 )
  {
    if ( v39 == (char *)-1 )
    {
      v11 = *(&s - 20);
      v23 = (char *)(unsigned __int8)(*(&s - 14))[(_DWORD)v11];
      LOBYTE(v23) = (_BYTE)v23 != 0;
    }
    else
    {
      v23 = *(&s - 14);
      LOBYTE(v23) = v23 != v39;
    }
    if ( !(_BYTE)v23 )
      break;
    *((_BYTE *)&s - 65) = 0;
    *((_BYTE *)&s - 64) = 0;
    *((_BYTE *)&s - 63) = 0;
    if ( *((_BYTE *)&s - 72) && v40 != 2 && *(&s - 10) )
    {
      a1 = &(*(&s - 10))[(_DWORD)*(&s - 14)];
      if ( v39 != (char *)-1 || (unsigned int)*(&s - 10) <= 1 )
      {
        v13 = (size_t)v39;
      }
      else
      {
        s = *(&s - 20);
        v13 = strlen(s);
        v39 = (char *)v13;
      }
      if ( (unsigned int)a1 <= v13 )
      {
        v14 = &(*(&s - 20))[(_DWORD)*(&s - 14)];
        n = (size_t)*(&s - 10);
        s2 = *(&s - 11);
        if ( !memcmp(v14, s2, n) )
        {
          v15 = *((_BYTE *)&s - 71) == 0;
          v33 = 0;
          v32 = a1;
          v16 = &loc_804F30F;
          if ( v15 )
            v16 = &loc_804F314;
          dword_805B188 = (int)v16;
          a1 = v32;
          sub_8055AF8(s, s2, n, p, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48);
          goto LABEL_247;
        }
      }
    }
    v11 = *(&s - 20);
    *((_BYTE *)&s - 67) = (*(&s - 14))[(_DWORD)v11];
    switch ( *((unsigned __int8 *)&s - 67) )
    {
      case 0u:
        if ( *((_BYTE *)&s - 72) )
        {
          if ( *((_BYTE *)&s - 71) )
            goto LABEL_247;
          *((_BYTE *)&s - 64) = 1;
          if ( v40 == 2 && *((_BYTE *)&s - 70) != 1 )
          {
            if ( *(&s - 13) < (char *)p )
            {
              v11 = *(&s - 19);
              (*(&s - 13))[(_DWORD)v11] = 39;
            }
            if ( ++*(&s - 13) < (char *)p )
            {
              v11 = *(&s - 19);
              (*(&s - 13))[(_DWORD)v11] = 36;
            }
            if ( ++*(&s - 13) < (char *)p )
            {
              v11 = *(&s - 19);
              (*(&s - 13))[(_DWORD)v11] = 39;
            }
            ++*(&s - 13);
            *((_BYTE *)&s - 70) = 1;
          }
          if ( *(&s - 13) < (char *)p )
          {
            v11 = *(&s - 19);
            (*(&s - 13))[(_DWORD)v11] = 92;
          }
          ++*(&s - 13);
          if ( v40 != 2 && *(&s - 14) + 1 < v39 )
          {
            v11 = *(&s - 14) + 1;
            if ( (*(&s - 20))[(_DWORD)v11] > 47 )
            {
              v11 = *(&s - 14) + 1;
              if ( (*(&s - 20))[(_DWORD)v11] <= 57 )
              {
                if ( *(&s - 13) < (char *)p )
                {
                  v11 = *(&s - 19);
                  (*(&s - 13))[(_DWORD)v11] = 48;
                }
                if ( ++*(&s - 13) < (char *)p )
                {
                  v11 = *(&s - 19);
                  (*(&s - 13))[(_DWORD)v11] = 48;
                }
                ++*(&s - 13);
              }
            }
          }
          *((_BYTE *)&s - 67) = 48;
          dword_805B174 = (int)&loc_804F453;
          sub_8055B70(v12, v11);
        }
        if ( v41 & 1 )
          goto LABEL_222;
        goto LABEL_192;
      case 7u:
        *((_BYTE *)&s - 66) = 97;
        goto LABEL_104;
      case 8u:
        *((_BYTE *)&s - 66) = 98;
        goto LABEL_104;
      case 9u:
        *((_BYTE *)&s - 66) = 116;
        goto LABEL_102;
      case 0xAu:
        *((_BYTE *)&s - 66) = 110;
        goto LABEL_102;
      case 0xBu:
        *((_BYTE *)&s - 66) = 118;
        goto LABEL_104;
      case 0xCu:
        *((_BYTE *)&s - 66) = 102;
        goto LABEL_104;
      case 0xDu:
        *((_BYTE *)&s - 66) = 114;
        goto LABEL_102;
      case 0x20u:
        goto LABEL_112;
      case 0x21u:
      case 0x22u:
      case 0x24u:
      case 0x26u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x3Bu:
      case 0x3Cu:
      case 0x3Du:
      case 0x3Eu:
      case 0x5Bu:
      case 0x5Eu:
      case 0x60u:
      case 0x7Cu:
        goto LABEL_113;
      case 0x23u:
      case 0x7Eu:
        goto LABEL_111;
      case 0x25u:
      case 0x2Bu:
      case 0x2Cu:
      case 0x2Du:
      case 0x2Eu:
      case 0x2Fu:
      case 0x30u:
      case 0x31u:
      case 0x32u:
      case 0x33u:
      case 0x34u:
      case 0x35u:
      case 0x36u:
      case 0x37u:
      case 0x38u:
      case 0x39u:
      case 0x3Au:
      case 0x41u:
      case 0x42u:
      case 0x43u:
      case 0x44u:
      case 0x45u:
      case 0x46u:
      case 0x47u:
      case 0x48u:
      case 0x49u:
      case 0x4Au:
      case 0x4Bu:
      case 0x4Cu:
      case 0x4Du:
      case 0x4Eu:
      case 0x4Fu:
      case 0x50u:
      case 0x51u:
      case 0x52u:
      case 0x53u:
      case 0x54u:
      case 0x55u:
      case 0x56u:
      case 0x57u:
      case 0x58u:
      case 0x59u:
      case 0x5Au:
      case 0x5Du:
      case 0x5Fu:
      case 0x61u:
      case 0x62u:
      case 0x63u:
      case 0x64u:
      case 0x65u:
      case 0x66u:
      case 0x67u:
      case 0x68u:
      case 0x69u:
      case 0x6Au:
      case 0x6Bu:
      case 0x6Cu:
      case 0x6Du:
      case 0x6Eu:
      case 0x6Fu:
      case 0x70u:
      case 0x71u:
      case 0x72u:
      case 0x73u:
      case 0x74u:
      case 0x75u:
      case 0x76u:
      case 0x77u:
      case 0x78u:
      case 0x79u:
      case 0x7Au:
        *((_BYTE *)&s - 63) = 1;
        goto LABEL_192;
      case 0x27u:
        *((_BYTE *)&s - 69) = 1;
        *((_BYTE *)&s - 63) = 1;
        if ( v40 != 2 )
          goto LABEL_192;
        if ( *((_BYTE *)&s - 71) )
          goto LABEL_247;
        if ( p && !*(&s - 12) )
        {
          *(&s - 12) = (char *)p;
          p = 0;
        }
        if ( *(&s - 13) < (char *)p )
        {
          v11 = *(&s - 19);
          (*(&s - 13))[(_DWORD)v11] = 39;
        }
        if ( ++*(&s - 13) < (char *)p )
        {
          v11 = *(&s - 19);
          (*(&s - 13))[(_DWORD)v11] = 92;
        }
        if ( ++*(&s - 13) < (char *)p )
        {
          v11 = *(&s - 19);
          (*(&s - 13))[(_DWORD)v11] = 39;
        }
        ++*(&s - 13);
        *((_BYTE *)&s - 70) = 0;
        goto LABEL_192;
      case 0x3Fu:
        if ( v40 == 2 )
        {
          if ( *((_BYTE *)&s - 71) )
          {
            dword_805B19C = (int)&loc_804FD6A;
            sub_8055A8A(
              v12,
              v11,
              s,
              s2,
              n,
              p,
              v38,
              v39,
              v40,
              v41,
              v42,
              v43,
              v44,
              v45,
              v46,
              v47,
              v48,
              v49,
              v50,
              v51,
              v52,
              v53,
              v54,
              v55,
              v56);
          }
        }
        else if ( v40 == 5 )
        {
          if ( v41 & 4 )
          {
            if ( *(&s - 14) + 2 < v39 )
            {
              v11 = *(&s - 14) + 1;
              if ( (*(&s - 20))[(_DWORD)v11] == 63 )
              {
                v11 = *(&s - 14) + 2;
                switch ( (*(&s - 20))[(_DWORD)v11] )
                {
                  case 33:
                  case 39:
                  case 40:
                  case 41:
                  case 45:
                  case 47:
                  case 60:
                  case 61:
                  case 62:
                    if ( *((_BYTE *)&s - 71) )
                      goto LABEL_247;
                    v11 = *(&s - 14) + 2;
                    *((_BYTE *)&s - 67) = (*(&s - 20))[(_DWORD)v11];
                    *(&s - 14) += 2;
                    if ( *(&s - 13) < (char *)p )
                    {
                      v11 = *(&s - 19);
                      (*(&s - 13))[(_DWORD)v11] = 63;
                    }
                    if ( ++*(&s - 13) < (char *)p )
                    {
                      v11 = *(&s - 19);
                      (*(&s - 13))[(_DWORD)v11] = 34;
                    }
                    if ( ++*(&s - 13) < (char *)p )
                    {
                      v11 = *(&s - 19);
                      (*(&s - 13))[(_DWORD)v11] = 34;
                    }
                    if ( ++*(&s - 13) < (char *)p )
                    {
                      v11 = *(&s - 19);
                      (*(&s - 13))[(_DWORD)v11] = 63;
                    }
                    ++*(&s - 13);
                    break;
                  default:
                    goto LABEL_192;
                }
              }
            }
          }
        }
        goto LABEL_192;
      case 0x5Cu:
        v17 = (char *)*((unsigned __int8 *)&s - 67);
        *((_BYTE *)&s - 66) = (_BYTE)v17;
        if ( v40 == 2 )
        {
          if ( *((_BYTE *)&s - 71) )
            goto LABEL_247;
        }
        else
        {
          if ( !*((_BYTE *)&s - 72) )
            goto LABEL_102;
          v15 = *((_BYTE *)&s - 71) == 0;
          v33 = v17;
          v32 = a1;
          v18 = &loc_804F5D7;
          if ( v15 )
            v18 = &loc_804F5E2;
          dword_805B188 = (int)v18;
          a1 = v32;
          sub_8055AF8(s, s2, n, p, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48);
          if ( !*(&s - 10) )
          {
LABEL_102:
            if ( v40 == 2 && *((_BYTE *)&s - 71) )
              goto LABEL_247;
LABEL_104:
            if ( *((_BYTE *)&s - 72) )
            {
              *((_BYTE *)&s - 67) = *((_BYTE *)&s - 66);
            }
            else
            {
LABEL_192:
              if ( (*((_BYTE *)&s - 72) != 1 || v40 == 2) && *((_BYTE *)&s - 71) != 1
                || !*(&s - 21)
                || (v12 = *((_BYTE *)&s - 67) & 0x1F,
                    v11 = (char *)(*(_DWORD *)&(*(&s - 21))[4 * (unsigned __int8)(*((_BYTE *)&s - 67) >> 5)] >> v12),
                    !((unsigned __int8)v11 & 1)) )
              {
                if ( *((_BYTE *)&s - 65) != 1 )
                  goto LABEL_211;
              }
            }
            if ( *((_BYTE *)&s - 71) )
              goto LABEL_247;
            *((_BYTE *)&s - 64) = 1;
            if ( v40 == 2 && *((_BYTE *)&s - 70) != 1 )
            {
              if ( *(&s - 13) < (char *)p )
              {
                v11 = *(&s - 19);
                (*(&s - 13))[(_DWORD)v11] = 39;
              }
              if ( ++*(&s - 13) < (char *)p )
              {
                v11 = *(&s - 19);
                (*(&s - 13))[(_DWORD)v11] = 36;
              }
              if ( ++*(&s - 13) < (char *)p )
              {
                v11 = *(&s - 19);
                (*(&s - 13))[(_DWORD)v11] = 39;
              }
              ++*(&s - 13);
              *((_BYTE *)&s - 70) = 1;
            }
            if ( *(&s - 13) < (char *)p )
            {
              v11 = *(&s - 19);
              (*(&s - 13))[(_DWORD)v11] = 92;
            }
            ++*(&s - 13);
          }
        }
LABEL_211:
        if ( *((_BYTE *)&s - 70) && *((_BYTE *)&s - 64) != 1 )
        {
          if ( *(&s - 13) < (char *)p )
          {
            v11 = *(&s - 19);
            (*(&s - 13))[(_DWORD)v11] = 39;
          }
          if ( ++*(&s - 13) < (char *)p )
          {
            v11 = *(&s - 19);
            (*(&s - 13))[(_DWORD)v11] = 39;
          }
          ++*(&s - 13);
          *((_BYTE *)&s - 70) = 0;
        }
        if ( *(&s - 13) < (char *)p )
        {
          v11 = &(*(&s - 19))[(_DWORD)*(&s - 13)];
          *v11 = *((_BYTE *)&s - 67);
        }
        ++*(&s - 13);
        if ( *((_BYTE *)&s - 63) != 1 )
          *((_BYTE *)&s - 68) = 0;
LABEL_222:
        ++*(&s - 14);
        break;
      case 0x7Bu:
      case 0x7Du:
        if ( v39 == (char *)-1 )
          v19 = (*(&s - 20))[1] != 0;
        else
          v19 = v39 != (char *)1;
        if ( v19 )
          goto LABEL_192;
LABEL_111:
        if ( *(&s - 14) )
          goto LABEL_192;
LABEL_112:
        *((_BYTE *)&s - 63) = 1;
LABEL_113:
        if ( v40 != 2 || !*((_BYTE *)&s - 71) )
          goto LABEL_192;
        goto LABEL_247;
      default:
        if ( *((_BYTE *)&s - 61) )
        {
          *(&s - 9) = (char *)1;
          v20 = __ctype_b_loc();
          v11 = (char *)(2 * *((unsigned __int8 *)&s - 67));
          *((_BYTE *)&s - 62) = (*(const unsigned __int16 *)((_BYTE *)*v20 + (_DWORD)v11) & 0x4000) != 0;
          goto LABEL_152;
        }
        memset(&s - 5, 0, 8u);
        *(&s - 9) = 0;
        *((_BYTE *)&s - 62) = 1;
        if ( v39 == (char *)-1 )
        {
          s = *(&s - 20);
          v39 = (char *)strlen(s);
        }
        while ( 2 )
        {
          *(&s - 7) = (char *)sub_80525B3(
                                (wchar_t *)&s - 15,
                                &(*(&s - 20))[(unsigned int)&(*(&s - 14))[(_DWORD)*(&s - 9)]],
                                v39 - &(*(&s - 14))[(_DWORD)*(&s - 9)],
                                (mbstate_t *)(&s - 5));
          if ( *(&s - 7) )
          {
            if ( *(&s - 7) == (char *)-1 )
            {
              *((_BYTE *)&s - 62) = 0;
            }
            else
            {
              if ( *(&s - 7) != (char *)-2 )
              {
                if ( *((_BYTE *)&s - 71) && v40 == 2 )
                {
                  *(&s - 8) = (char *)1;
                  while ( *(&s - 8) < *(&s - 7) )
                  {
                    switch ( (*(&s - 8))[(unsigned int)&(*(&s - 14))[(_DWORD)*(&s - 9)] + (_DWORD)*(&s - 20)] )
                    {
                      case 91:
                      case 92:
                      case 94:
                      case 96:
                      case 124:
                        goto LABEL_247;
                      default:
                        ++*(&s - 8);
                        break;
                    }
                  }
                }
                s = *(&s - 15);
                if ( !iswprint((wint_t)s) )
                  *((_BYTE *)&s - 62) = 0;
                *(&s - 9) = &(*(&s - 9))[(_DWORD)*(&s - 7)];
                if ( mbsinit((const mbstate_t *)(&s - 5)) )
                  break;
                continue;
              }
              *((_BYTE *)&s - 62) = 0;
              while ( 1 )
              {
                v11 = *(&s - 14);
                if ( &(*(&s - 9))[(signed int)v11] >= v39 )
                  break;
                v11 = &(*(&s - 14))[(_DWORD)*(&s - 9)];
                if ( !(*(&s - 20))[(_DWORD)v11] )
                  break;
                ++*(&s - 9);
              }
            }
          }
          break;
        }
LABEL_152:
        *((_BYTE *)&s - 63) = *((_BYTE *)&s - 62);
        if ( (unsigned int)*(&s - 9) <= 1 && (!*((_BYTE *)&s - 72) || *((_BYTE *)&s - 62) == 1) )
          goto LABEL_192;
        v11 = *(&s - 14);
        *(&s - 6) = &(*(&s - 9))[(_DWORD)v11];
        while ( 1 )
        {
          if ( *((_BYTE *)&s - 72) && *((_BYTE *)&s - 62) != 1 )
          {
            if ( *((_BYTE *)&s - 71) )
              goto LABEL_247;
            *((_BYTE *)&s - 64) = 1;
            if ( v40 == 2 )
            {
              v15 = *((_BYTE *)&s - 70) == 1;
              v33 = (char *)(*((unsigned __int8 *)&s - 70) ^ 1);
              v32 = a1;
              v21 = &loc_804F915;
              if ( v15 )
                v21 = &loc_804F95E;
              dword_805B160 = (int)v21;
              a1 = v32;
              sub_8055BDC(
                s,
                s2,
                n,
                p,
                v38,
                v39,
                v40,
                v41,
                v42,
                v43,
                v44,
                v45,
                v46,
                v47,
                v48,
                v49,
                v50,
                v51,
                v52,
                v53,
                v54,
                v55,
                v56,
                v57,
                v58,
                v59,
                v60,
                v61,
                v62,
                v63,
                v64,
                v65,
                v66);
              if ( *(&s - 13) < (char *)p )
              {
                v11 = *(&s - 19);
                (*(&s - 13))[(_DWORD)v11] = 39;
              }
              if ( ++*(&s - 13) < (char *)p )
              {
                v11 = *(&s - 19);
                (*(&s - 13))[(_DWORD)v11] = 36;
              }
              if ( ++*(&s - 13) < (char *)p )
              {
                v11 = *(&s - 19);
                (*(&s - 13))[(_DWORD)v11] = 39;
              }
              ++*(&s - 13);
              *((_BYTE *)&s - 70) = 1;
            }
            if ( *(&s - 13) < (char *)p )
            {
              v11 = *(&s - 19);
              (*(&s - 13))[(_DWORD)v11] = 92;
            }
            if ( ++*(&s - 13) < (char *)p )
            {
              v11 = &(*(&s - 19))[(_DWORD)*(&s - 13)];
              *v11 = (*((_BYTE *)&s - 67) >> 6) + 48;
            }
            if ( ++*(&s - 13) < (char *)p )
            {
              v11 = &(*(&s - 19))[(_DWORD)*(&s - 13)];
              *v11 = ((*((_BYTE *)&s - 67) >> 3) & 7) + 48;
            }
            ++*(&s - 13);
            *((_BYTE *)&s - 67) = (*((_BYTE *)&s - 67) & 7) + 48;
          }
          else if ( *((_BYTE *)&s - 65) )
          {
            if ( *(&s - 13) < (char *)p )
            {
              v11 = *(&s - 19);
              (*(&s - 13))[(_DWORD)v11] = 92;
            }
            ++*(&s - 13);
            *((_BYTE *)&s - 65) = 0;
          }
          if ( *(&s - 14) + 1 >= *(&s - 6) )
            goto LABEL_211;
          v15 = *((_BYTE *)&s - 70) == 0;
          v33 = *(&s - 14) + 1;
          v32 = a1;
          v22 = &loc_804FA17;
          if ( v15 )
            v22 = &loc_804FA54;
          dword_805B188 = (int)v22;
          a1 = v32;
          sub_8055AF8(s, s2, n, p, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48);
          if ( *((_BYTE *)&s - 64) != 1 )
          {
            if ( *(&s - 13) < (char *)p )
              (*(&s - 13))[(_DWORD)*(&s - 19)] = 39;
            if ( ++*(&s - 13) < (char *)p )
              (*(&s - 13))[(_DWORD)*(&s - 19)] = 39;
            ++*(&s - 13);
            *((_BYTE *)&s - 70) = 0;
          }
          if ( *(&s - 13) < (char *)p )
            (*(&s - 19))[(_DWORD)*(&s - 13)] = *((_BYTE *)&s - 67);
          ++*(&s - 13);
          ++*(&s - 14);
          v11 = *(&s - 20);
          *((_BYTE *)&s - 67) = (*(&s - 14))[(_DWORD)v11];
        }
    }
  }
  v15 = *(&s - 13) == 0;
  v33 = v23;
  v32 = a1;
  v24 = &loc_804FC3B;
  if ( !v15 )
    v24 = &loc_804FC4C;
  dword_805B19C = (int)v24;
  a1 = v32;
  sub_8055A8A(
    v12,
    v11,
    s,
    s2,
    n,
    p,
    v38,
    v39,
    v40,
    v41,
    v42,
    v43,
    v44,
    v45,
    v46,
    v47,
    v48,
    v49,
    v50,
    v51,
    v52,
    v53,
    v54,
    v55,
    v56);
  if ( v40 != 2 || !*((_BYTE *)&s - 71) )
  {
    if ( v40 == 2 && *((_BYTE *)&s - 71) != 1 && *((_BYTE *)&s - 69) )
    {
      v15 = *((_BYTE *)&s - 68) == 0;
      v33 = (char *)(*((unsigned __int8 *)&s - 71) ^ 1);
      v32 = a1;
      v27 = &loc_804FC8E;
      if ( v15 )
        v27 = &loc_804FCF7;
      dword_805B174 = (int)v27;
      a1 = v32;
      sub_8055B70(v26, v25);
      v42 = (int)*(&s - 23);
      v41 = (size_t)*(&s - 22);
      v40 = (int)*(&s - 21);
      v39 = (char *)v41;
      v38 = 5;
      p = (mbstate_t *)v41;
      n = (size_t)*(&s - 20);
      s2 = *(&s - 12);
      s = *(&s - 19);
      v28 = sub_804F03E(s, s2, n, v41, 5);
    }
    else
    {
      if ( *(&s - 11) && *((_BYTE *)&s - 71) != 1 )
      {
        while ( **(&s - 11) )
        {
          if ( *(&s - 13) < (char *)p )
            (*(&s - 19))[(_DWORD)*(&s - 13)] = **(&s - 11);
          ++*(&s - 13);
          ++*(&s - 11);
        }
      }
      if ( *(&s - 13) < (char *)p )
        (*(&s - 13))[(_DWORD)*(&s - 19)] = 0;
      v28 = (int)*(&s - 13);
    }
    goto LABEL_251;
  }
LABEL_247:
  if ( v40 == 2 && *((_BYTE *)&s - 72) )
    v40 = 4;
  v29 = (mbstate_t *)(v41 & 0xFFFFFFFD);
  v42 = (int)*(&s - 23);
  v41 = (size_t)*(&s - 22);
  v40 = 0;
  v39 = (char *)v29;
  v38 = 0;
  p = v29;
  n = (size_t)*(&s - 20);
  s2 = v29;
  s = *(&s - 19);
  v28 = sub_804F03E(s, v39, n, v39, 0);
LABEL_251:
  v15 = __readgsdword(0x14u) == (_DWORD)*(&s - 3);
  v33 = (char *)v28;
  v32 = a1;
  v30 = (int (*)())&loc_804FE0B;
  if ( v15 )
    v30 = sub_804FE10;
  dword_805B160 = (int)v30;
  return sub_8055BDC(
           s,
           s2,
           n,
           p,
           v38,
           v39,
           v40,
           v41,
           v42,
           v43,
           v44,
           v45,
           v46,
           v47,
           v48,
           v49,
           v50,
           v51,
           v52,
           v53,
           v54,
           v55,
           v56,
           v57,
           v58,
           v59,
           v60,
           v61,
           v62,
           v63,
           v64,
           v65,
           v66);
}
// 804F063: could not find valid save-restore pair for ebx
// 804F03E: using guessed type int __cdecl sub_804F03E(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 804FE10: using guessed type int sub_804FE10();
// 8055A8A: using guessed type int __fastcall sub_8055A8A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8055AF8: using guessed type int __stdcall sub_8055AF8(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8055B70: using guessed type int __fastcall sub_8055B70(_DWORD, _DWORD);
// 8055BDC: using guessed type int __stdcall sub_8055BDC(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805B160: using guessed type int dword_805B160;
// 805B174: using guessed type int dword_805B174;
// 805B188: using guessed type int dword_805B188;
// 805B19C: using guessed type int dword_805B19C;

//----- (0804FE10) --------------------------------------------------------
#error "804FE13: positive sp value has been found (funcsize=0)"

//----- (0804FEFD) --------------------------------------------------------
#error "804FF1E: call analysis failed (funcsize=29)"

//----- (0804FF58) --------------------------------------------------------
#error "8050087: positive sp value has been found (funcsize=83)"

//----- (08050122) --------------------------------------------------------
#error "805029B: call analysis failed (funcsize=103)"

//----- (080502A0) --------------------------------------------------------
#error "80502DE: call analysis failed (funcsize=24)"

//----- (080502F1) --------------------------------------------------------
#error "80503F2: positive sp value has been found (funcsize=70)"

//----- (080503F5) --------------------------------------------------------
int __cdecl sub_80503F5(int a1, int a2)
{
  return sub_8050122(a1, a2, -1, &dword_805BB5B);
}
// 8050122: using guessed type _DWORD __cdecl sub_8050122(_DWORD, _DWORD, _DWORD, _DWORD);
// 805BB5B: using guessed type int dword_805BB5B;

//----- (0805041F) --------------------------------------------------------
#error "805044C: call analysis failed (funcsize=15)"

//----- (08050451) --------------------------------------------------------
#error "805046C: positive sp value has been found (funcsize=0)"

//----- (080504AA) --------------------------------------------------------
int __cdecl sub_80504AA(int a1, int a2, int a3)
{
  char v4; // [esp+10h] [ebp-38h]

  sub_804EEC8(&v4, a2);
  return sub_8050122(a1, a3, -1, &v4);
}
// 8050122: using guessed type _DWORD __cdecl sub_8050122(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080504E8) --------------------------------------------------------
int __cdecl sub_80504E8(int a1, int a2, int a3, int a4)
{
  char v5; // [esp+10h] [ebp-38h]

  sub_804EEC8(&v5, a2);
  return sub_8050122(a1, a3, a4, &v5);
}
// 8050122: using guessed type _DWORD __cdecl sub_8050122(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08050580) --------------------------------------------------------
int __cdecl sub_8050580(int a1, int a2, unsigned __int8 a3)
{
  int v4; // [esp+0h] [ebp-58h]
  unsigned __int8 v5; // [esp+1Ch] [ebp-3Ch]
  int v6; // [esp+20h] [ebp-38h]
  int v7; // [esp+24h] [ebp-34h]
  int v8; // [esp+28h] [ebp-30h]
  int v9; // [esp+2Ch] [ebp-2Ch]
  int v10; // [esp+30h] [ebp-28h]
  int v11; // [esp+34h] [ebp-24h]
  int v12; // [esp+38h] [ebp-20h]
  int v13; // [esp+3Ch] [ebp-1Ch]
  int v14; // [esp+40h] [ebp-18h]
  int v15; // [esp+44h] [ebp-14h]
  int v16; // [esp+48h] [ebp-10h]
  int v17; // [esp+4Ch] [ebp-Ch]

  v5 = a3;
  v6 = dword_805BB5B;
  v7 = dword_805BB5F;
  v8 = dword_805BB63;
  v9 = dword_805BB67;
  v10 = dword_805BB6B;
  v11 = dword_805BB6F;
  v12 = dword_805BB73;
  v13 = dword_805BB77;
  v14 = dword_805BB7B;
  v15 = dword_805BB7F;
  v16 = dword_805BB83;
  v17 = dword_805BB87;
  sub_804EDBD(&v4 - 14, a3, 1);
  return sub_8050122(0, a1, a2, &v6);
}
// 8050122: using guessed type _DWORD __cdecl sub_8050122(_DWORD, _DWORD, _DWORD, _DWORD);
// 805BB5B: using guessed type int dword_805BB5B;
// 805BB5F: using guessed type int dword_805BB5F;
// 805BB63: using guessed type int dword_805BB63;
// 805BB67: using guessed type int dword_805BB67;
// 805BB6B: using guessed type int dword_805BB6B;
// 805BB6F: using guessed type int dword_805BB6F;
// 805BB73: using guessed type int dword_805BB73;
// 805BB77: using guessed type int dword_805BB77;
// 805BB7B: using guessed type int dword_805BB7B;
// 805BB7F: using guessed type int dword_805BB7F;
// 805BB83: using guessed type int dword_805BB83;
// 805BB87: using guessed type int dword_805BB87;

//----- (0805064A) --------------------------------------------------------
int __cdecl sub_805064A(int a1, unsigned __int8 a2)
{
  return sub_8050580(a1, -1, a2);
}

//----- (08050683) --------------------------------------------------------
int __cdecl sub_8050683(int a1)
{
  return sub_805064A(a1, 0x3Au);
}

//----- (080506C0) --------------------------------------------------------
int __cdecl sub_80506C0(int a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-78h]
  int v5; // [esp+10h] [ebp-68h]
  int v6; // [esp+14h] [ebp-64h]
  int v7; // [esp+18h] [ebp-60h]
  int v8; // [esp+1Ch] [ebp-5Ch]
  int v9; // [esp+20h] [ebp-58h]
  int v10; // [esp+24h] [ebp-54h]
  int v11; // [esp+28h] [ebp-50h]
  int v12; // [esp+2Ch] [ebp-4Ch]
  int v13; // [esp+30h] [ebp-48h]
  int v14; // [esp+34h] [ebp-44h]
  int v15; // [esp+38h] [ebp-40h]
  int v16; // [esp+3Ch] [ebp-3Ch]
  int v17; // [esp+40h] [ebp-38h]
  int v18; // [esp+44h] [ebp-34h]
  int v19; // [esp+48h] [ebp-30h]
  int v20; // [esp+4Ch] [ebp-2Ch]
  int v21; // [esp+50h] [ebp-28h]
  int v22; // [esp+54h] [ebp-24h]
  int v23; // [esp+58h] [ebp-20h]
  int v24; // [esp+5Ch] [ebp-1Ch]
  int v25; // [esp+60h] [ebp-18h]
  int v26; // [esp+64h] [ebp-14h]
  int v27; // [esp+68h] [ebp-10h]
  int v28; // [esp+6Ch] [ebp-Ch]

  sub_804EEC8(&v5, a2);
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v25 = v13;
  v26 = v14;
  v27 = v15;
  v28 = v16;
  sub_804EDBD(&v4 - 14, 0x3Au, 1);
  return sub_8050122(a1, a3, -1, &v17);
}
// 8050122: using guessed type _DWORD __cdecl sub_8050122(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08050781) --------------------------------------------------------
int sub_8050781()
{
  return sub_80507D1();
}

//----- (080507D1) --------------------------------------------------------
int sub_80507D1()
{
  int v1; // [esp+0h] [ebp-4Ch]
  int v2; // [esp+Ch] [ebp-40h]
  int v3; // [esp+10h] [ebp-3Ch]
  int v4; // [esp+14h] [ebp-38h]
  int v5; // [esp+18h] [ebp-34h]
  int v6; // [esp+1Ch] [ebp-30h]
  int v7; // [esp+20h] [ebp-2Ch]
  int v8; // [esp+24h] [ebp-28h]
  int v9; // [esp+28h] [ebp-24h]
  int v10; // [esp+2Ch] [ebp-20h]
  int v11; // [esp+30h] [ebp-1Ch]
  int v12; // [esp+34h] [ebp-18h]

  v3 = dword_805BB5B;
  v4 = dword_805BB5F;
  v5 = dword_805BB63;
  v6 = dword_805BB67;
  v7 = dword_805BB6B;
  v8 = dword_805BB6F;
  v9 = dword_805BB73;
  v10 = dword_805BB77;
  v11 = dword_805BB7B;
  v12 = dword_805BB7F;
  *(&v1 - 4) = dword_805BB83;
  *(&v1 - 3) = dword_805BB87;
  sub_804EE87(&v1 - 14, v2, v3);
  return sub_8050122(v5, v4, v5, &v1 - 14);
}
// 8050122: using guessed type _DWORD __cdecl sub_8050122(_DWORD, _DWORD, _DWORD, _DWORD);
// 805BB5B: using guessed type int dword_805BB5B;
// 805BB5F: using guessed type int dword_805BB5F;
// 805BB63: using guessed type int dword_805BB63;
// 805BB67: using guessed type int dword_805BB67;
// 805BB6B: using guessed type int dword_805BB6B;
// 805BB6F: using guessed type int dword_805BB6F;
// 805BB73: using guessed type int dword_805BB73;
// 805BB77: using guessed type int dword_805BB77;
// 805BB7B: using guessed type int dword_805BB7B;
// 805BB7F: using guessed type int dword_805BB7F;
// 805BB83: using guessed type int dword_805BB83;
// 805BB87: using guessed type int dword_805BB87;

//----- (08050940) --------------------------------------------------------
int __cdecl sub_8050940(int a1, int a2, int a3)
{
  return sub_8050122(a1, a2, a3, &unk_805B228);
}
// 8050122: using guessed type _DWORD __cdecl sub_8050122(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0805099B) --------------------------------------------------------
int __cdecl sub_805099B(int a1, int a2)
{
  return sub_8050940(a1, a2, -1);
}

//----- (080509BD) --------------------------------------------------------
int __cdecl sub_80509BD(int a1)
{
  return sub_805099B(0, a1);
}

//----- (080509D8) --------------------------------------------------------
char *__cdecl sub_80509D8(FILE *stream, int a2)
{
  int v2; // eax
  int v3; // edx
  size_t n; // ST20_4
  size_t v6; // ST24_4
  char *ptr; // [esp+10h] [ebp-98h]
  unsigned int size; // [esp+14h] [ebp-94h]
  unsigned int v9; // [esp+18h] [ebp-90h]
  signed int v10; // [esp+1Ch] [ebp-8Ch]
  char *v11; // [esp+28h] [ebp-80h]
  char *v12; // [esp+2Ch] [ebp-7Ch]
  __int64 v13; // [esp+30h] [ebp-78h]
  char v14; // [esp+40h] [ebp-68h]
  int v15; // [esp+50h] [ebp-58h]
  __int64 v16; // [esp+6Ch] [ebp-3Ch]

  size = 0x2000;
  v2 = fileno(stream);
  if ( sub_8055904(v2, (int)&v14) >= 0 && (v15 & 0xF000) == 0x8000 )
  {
    LODWORD(v13) = ftello64(stream);
    HIDWORD(v13) = v3;
    if ( v3 >= 0 && v16 > v13 )
    {
      if ( v16 - v13 > 4294967294LL )
      {
        *__errno_location() = 12;
        return 0;
      }
      size = v16 - v13 + 1;
    }
  }
  ptr = (char *)malloc(size);
  if ( !ptr )
    return 0;
  v9 = 0;
  while ( 1 )
  {
    n = size - v9;
    v6 = fread(&ptr[v9], 1u, size - v9, stream);
    v9 += v6;
    if ( v6 != n )
      break;
    if ( size == -1 )
    {
      v10 = 12;
      goto LABEL_25;
    }
    if ( ~(size >> 1) <= size )
      size = -1;
    else
      size += size >> 1;
    v12 = (char *)realloc(ptr, size);
    if ( !v12 )
    {
      v10 = *__errno_location();
      goto LABEL_25;
    }
    ptr = v12;
  }
  v10 = *__errno_location();
  if ( ferror(stream) )
  {
LABEL_25:
    free(ptr);
    *__errno_location() = v10;
    return 0;
  }
  if ( size - 1 > v9 )
  {
    v11 = (char *)realloc(ptr, v9 + 1);
    if ( v11 )
      ptr = v11;
  }
  ptr[v9] = 0;
  *(_DWORD *)a2 = v9;
  return ptr;
}
// 8049280: using guessed type int __cdecl ftello64(_DWORD);

//----- (08050C78) --------------------------------------------------------
char *__cdecl sub_8050C78(int a1, int a2, int a3)
{
  int v4; // [esp+14h] [ebp-14h]
  FILE *stream; // [esp+18h] [ebp-10h]
  char *ptr; // [esp+1Ch] [ebp-Ch]

  stream = (FILE *)fopen64(a1, a3);
  if ( !stream )
    return 0;
  ptr = sub_80509D8(stream, a2);
  v4 = *__errno_location();
  if ( !sub_805232A(stream) )
    return ptr;
  if ( ptr )
  {
    v4 = *__errno_location();
    free(ptr);
  }
  *__errno_location() = v4;
  return 0;
}
// 8049160: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (08050CFF) --------------------------------------------------------
char *__cdecl sub_8050CFF(int a1, int a2)
{
  return sub_8050C78(a1, a2, (int)&unk_8056FF4);
}

//----- (08050D43) --------------------------------------------------------
int __cdecl __noreturn sub_8050D43(const char *a1, int a2)
{
  _WORD *v2; // edx
  size_t v3; // eax
  void *v4; // eax
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  void *v8; // eax
  size_t v9; // eax
  size_t v10; // eax
  int v11; // ecx
  int v12; // ecx
  unsigned int v13; // et1
  int (*v14)(); // eax
  int v16; // [esp+0h] [ebp-68h]
  int v17; // [esp+4h] [ebp-64h]
  int v18; // [esp+8h] [ebp-60h]
  char *s; // [esp+Ch] [ebp-5Ch]
  signed int v20; // [esp+10h] [ebp-58h]
  char *v21; // [esp+14h] [ebp-54h]
  char *v22; // [esp+18h] [ebp-50h]
  char *i; // [esp+18h] [ebp-50h]
  char *v24; // [esp+18h] [ebp-50h]
  char *v25; // [esp+1Ch] [ebp-4Ch]
  size_t v26; // [esp+20h] [ebp-48h]
  char v27; // [esp+24h] [ebp-44h]
  int v28; // [esp+28h] [ebp-40h]
  int v29; // [esp+2Ch] [ebp-3Ch]
  char j; // [esp+30h] [ebp-38h]
  char *v31; // [esp+34h] [ebp-34h]
  int v32; // [esp+38h] [ebp-30h]
  char v33; // [esp+3Ch] [ebp-2Ch]
  wint_t wc; // [esp+40h] [ebp-28h]
  int v35; // [esp+44h] [ebp-24h]
  int v36; // [esp+48h] [ebp-20h]
  int v37; // [esp+4Ch] [ebp-1Ch]
  int v38; // [esp+50h] [ebp-18h]
  int v39; // [esp+54h] [ebp-14h]
  int v40; // [esp+58h] [ebp-10h]
  unsigned int v41; // [esp+5Ch] [ebp-Ch]

  s = (char *)a1;
  v41 = __readgsdword(0x14u);
  v25 = strdup(a1);
  if ( !v25 )
    sub_8051C24();
  if ( __ctype_get_mb_cur_max() <= 1 )
  {
    if ( a2 )
    {
      for ( i = v25; *i && (*__ctype_b_loc())[(unsigned __int8)*i] & 0x2000; ++i )
        ;
      v9 = strlen(i);
      memmove(v25, i, v9 + 1);
    }
    if ( a2 != 1 )
    {
      v10 = strlen(v25);
      v24 = &v25[v10 - 1];
      dword_805B174 = (int)&loc_8051091;
      sub_8055B70(v11, v10 - 1);
      do
      {
        *v24-- = 0;
        if ( v24 < v25 )
          break;
        v2 = *__ctype_b_loc();
      }
      while ( v2[(unsigned __int8)*v24] & 0x2000 );
    }
  }
  else
  {
    if ( a2 )
    {
      v31 = v25;
      v26 = (size_t)&v25[strlen(v25)];
      v27 = 0;
      memset(&v28, 0, 8u);
      for ( j = 0; (unsigned int)v31 < v26; j = 0 )
      {
        sub_8052DAB(&v26);
        if ( !v33 || !iswspace(wc) )
          break;
        v31 += v32;
      }
      v3 = strlen(v31);
      memmove(v25, v31, v3 + 1);
    }
    if ( a2 != 1 )
    {
      v20 = 0;
      v31 = v25;
      v26 = (size_t)&v25[strlen(v25)];
      v27 = 0;
      memset(&v28, 0, 8u);
      for ( j = 0; ; j = 0 )
      {
        v2 = v31;
        if ( (unsigned int)v31 >= v26 )
          break;
        sub_8052DAB(&v26);
        if ( v20 )
          goto LABEL_55;
        v4 = &loc_8050EB2;
        if ( !v33 )
          v4 = &loc_8050EC6;
        dword_805B19C = (int)v4;
        sub_8055A8A(
          v6,
          v5,
          v16,
          v17,
          v18,
          s,
          0,
          v21,
          v22,
          v25,
          v26,
          *(_DWORD *)&v27,
          v28,
          v29,
          *(_DWORD *)&j,
          v31,
          v32,
          *(_DWORD *)&v33,
          wc,
          v35,
          v36,
          v37,
          v38,
          v39,
          v40);
        if ( !iswspace(wc) )
        {
LABEL_55:
          if ( v20 || v33 == 1 && iswspace(wc) )
          {
            if ( v20 != 1 )
              goto LABEL_56;
            v7 = &loc_8050F1C;
            if ( v33 != 1 )
              v7 = &loc_8050F2B;
            dword_805B188 = (int)v7;
            sub_8055AF8(v16, v17, v18, s, 1, v21, v22, v25, v26, *(_DWORD *)&v27, v28, v29, *(_DWORD *)&j, v31, v32);
            if ( iswspace(wc) )
            {
LABEL_56:
              if ( v20 == 1 && v33 && iswspace(wc) )
              {
                v20 = 2;
                v21 = v31;
              }
              else
              {
                if ( v20 != 2 )
                  goto LABEL_57;
                v8 = &loc_8050F80;
                if ( !v33 )
                  v8 = &loc_8050F91;
                dword_805B174 = (int)v8;
                sub_8055B70(v6, v5);
                if ( !iswspace(wc) )
LABEL_57:
                  v20 = 1;
              }
            }
          }
          else
          {
            v20 = 1;
          }
        }
        v31 += v32;
      }
      if ( v20 == 2 )
        *v21 = 0;
    }
  }
  v13 = __readgsdword(0x14u);
  v12 = v13 ^ v41;
  v14 = (int (*)())&loc_80510F4;
  if ( v13 == v41 )
    v14 = sub_80510F9;
  dword_805B174 = (int)v14;
  return sub_8055B70(v12, v2);
}
// 80510F9: using guessed type int sub_80510F9();
// 8052DAB: using guessed type _DWORD __cdecl sub_8052DAB(_DWORD);
// 8055A8A: using guessed type int __fastcall sub_8055A8A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8055AF8: using guessed type int __stdcall sub_8055AF8(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8055B70: using guessed type int __fastcall sub_8055B70(_DWORD, _DWORD);
// 805B174: using guessed type int dword_805B174;
// 805B188: using guessed type int dword_805B188;
// 805B19C: using guessed type int dword_805B19C;

//----- (080510F9) --------------------------------------------------------
#error "80510FC: positive sp value has been found (funcsize=0)"

//----- (080510FF) --------------------------------------------------------
#error "80517C0: call analysis failed (funcsize=406)"

//----- (080518A1) --------------------------------------------------------
int __cdecl sub_80518A1(FILE *stream, int a2, int a3, int a4, int a5)
{
  int *v5; // eax
  unsigned int i; // [esp+24h] [ebp-34h]
  int v8[12]; // [esp+28h] [ebp-30h]

  for ( i = 0; i <= 9; ++i )
  {
    v5 = (int *)a5;
    a5 += 4;
    v8[i] = *v5;
    if ( !v8[i] )
      break;
  }
  return sub_80510FF(stream, a2, a3, a4, (int)v8, i);
}
// 80518A1: using guessed type int var_30[12];

//----- (08051917) --------------------------------------------------------
int sub_8051917(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+50h] [ebp+18h]

  va_start(va, a4);
  return sub_80518A1(stream, a2, a3, a4, (int)va);
}

//----- (080519C7) --------------------------------------------------------
void *__cdecl sub_80519C7(unsigned int a1, unsigned int a2)
{
  if ( 0x7FFFFFFF / a2 < a1 )
    sub_8051C24();
  return sub_8051AD4(a2 * a1);
}

//----- (08051A2A) --------------------------------------------------------
void *__cdecl sub_8051A2A(void *ptr, int a2, int a3)
{
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v4 = *(_DWORD *)a2;
  if ( ptr )
  {
    if ( 0x55555554u / a3 <= v4 )
      sub_8051C24();
    v4 += (v4 >> 1) + 1;
  }
  else
  {
    if ( !v4 )
      v4 = (0x40u / a3 == 0) + 0x40u / a3;
    if ( 0x7FFFFFFFu / a3 < v4 )
      sub_8051C24();
  }
  *(_DWORD *)a2 = v4;
  return sub_8051AFE(ptr, a3 * v4);
}

//----- (08051AC1) --------------------------------------------------------
void *__cdecl sub_8051AC1(size_t size)
{
  return sub_8051AD4(size);
}

//----- (08051AD4) --------------------------------------------------------
void *__cdecl sub_8051AD4(size_t size)
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = malloc(size);
  if ( !v2 && size )
    sub_8051C24();
  return v2;
}

//----- (08051AFE) --------------------------------------------------------
void *__cdecl sub_8051AFE(void *ptr, size_t size)
{
  void *result; // eax
  void *ptra; // [esp+20h] [ebp+8h]

  if ( size || !ptr )
  {
    ptra = realloc(ptr, size);
    if ( !ptra )
    {
      if ( size )
        sub_8051C24();
    }
    result = ptra;
  }
  else
  {
    free(ptr);
    result = 0;
  }
  return result;
}

//----- (08051BD6) --------------------------------------------------------
void *__cdecl sub_8051BD6(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_8051AD4(n);
  return memcpy(v2, src, n);
}

//----- (08051C24) --------------------------------------------------------
void __noreturn sub_8051C24()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(status, 0, "%s", v0);
  abort();
}

//----- (08051D19) --------------------------------------------------------
#error "8051D55: call analysis failed (funcsize=29)"

//----- (08051D70) --------------------------------------------------------
#error "8051E32: call analysis failed (funcsize=87)"

//----- (08051E8F) --------------------------------------------------------
int __cdecl sub_8051E8F(int a1, int a2, int a3)
{
  int v3; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; i |= sub_8051D70(a1, a2) )
  {
    v3 = a3--;
    if ( !v3 )
      break;
  }
  return i;
}
// 8051D70: using guessed type _DWORD __cdecl sub_8051D70(_DWORD, _DWORD);

//----- (08051EC5) --------------------------------------------------------
#error "8051F8D: call analysis failed (funcsize=95)"

//----- (0805232A) --------------------------------------------------------
int __cdecl sub_805232A(FILE *stream)
{
  int v2; // eax
  __int64 v3; // rax
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]

  v4 = 0;
  if ( fileno(stream) < 0 )
    return fclose(stream);
  if ( !__freading(stream) || (v2 = fileno(stream), LODWORD(v3) = lseek64(v2, 0, 0, 1), v3 != -1) )
  {
    if ( sub_8052426(stream) )
      v4 = *__errno_location();
  }
  v5 = fclose(stream);
  if ( v4 )
  {
    *__errno_location() = v4;
    v5 = -1;
  }
  return v5;
}
// 8049430: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080523ED) --------------------------------------------------------
int __cdecl sub_80523ED(_DWORD *a1)
{
  int result; // eax

  result = *a1 & 0x100;
  if ( result )
    result = sub_8052494(a1, 0, 0);
  return result;
}
// 8052494: using guessed type _DWORD __cdecl sub_8052494(_DWORD, _DWORD, _DWORD);

//----- (08052426) --------------------------------------------------------
#error "8052446: call analysis failed (funcsize=35)"

//----- (08052494) --------------------------------------------------------
#error "80524D5: call analysis failed (funcsize=21)"

//----- (080524DA) --------------------------------------------------------
#error "80525B2: positive sp value has been found (funcsize=67)"

//----- (080525B3) --------------------------------------------------------
size_t __cdecl sub_80525B3(wchar_t *pwc, char *s, size_t n, mbstate_t *p)
{
  bool v4; // zf
  int v5; // edx
  int v6; // ecx
  void *v7; // eax
  char v9; // [esp+18h] [ebp-10h]
  size_t v10; // [esp+1Ch] [ebp-Ch]

  if ( !pwc )
    pwc = (wchar_t *)&v9;
  v10 = mbrtowc(pwc, s, n, p);
  if ( v10 <= 0xFFFFFFFD || !n )
    return v10;
  v4 = (unsigned __int8)sub_8052739(0) == 1;
  v7 = &loc_8052620;
  if ( v4 )
    v7 = &loc_8052639;
  dword_805B174 = (int)v7;
  sub_8055B70(v6, v5);
  *pwc = (unsigned __int8)*s;
  return 1;
}
// 8055B70: using guessed type int __fastcall sub_8055B70(_DWORD, _DWORD);
// 805B174: using guessed type int dword_805B174;

//----- (0805263E) --------------------------------------------------------
#error "8052663: call analysis failed (funcsize=43)"

//----- (080526B8) --------------------------------------------------------
int __cdecl sub_80526B8(FILE *fp)
{
  bool v1; // ST1E_1
  bool v3; // [esp+1Dh] [ebp-Bh]
  bool v4; // [esp+1Fh] [ebp-9h]

  v3 = __fpending(fp) != 0;
  v1 = ferror_unlocked(fp) != 0;
  v4 = sub_805232A(fp) != 0;
  if ( !v1 && (!v4 || !v3 && *__errno_location() == 9) )
    return 0;
  if ( v4 != 1 )
    *__errno_location() = 0;
  return -1;
}

//----- (08052739) --------------------------------------------------------
int __cdecl sub_8052739(int category)
{
  bool v1; // zf
  int v2; // edx
  int v3; // ecx
  void *v4; // eax
  unsigned __int8 v6; // [esp+1Bh] [ebp-Dh]
  const char *s1; // [esp+1Ch] [ebp-Ch]

  v6 = 1;
  s1 = setlocale(category, 0);
  if ( s1 )
  {
    if ( strcmp(s1, "C") )
    {
      v1 = strcmp(s1, "POSIX") == 0;
      v4 = &loc_80527A6;
      if ( !v1 )
        v4 = &loc_80527AA;
      dword_805B174 = (int)v4;
      sub_8055B70(v3, v2);
    }
    v6 = 0;
  }
  return v6;
}
// 8055B70: using guessed type int __fastcall sub_8055B70(_DWORD, _DWORD);
// 805B174: using guessed type int dword_805B174;

//----- (080527B0) --------------------------------------------------------
void *sub_80527B0()
{
  _BOOL4 v0; // eax
  int v1; // edx
  int v2; // ecx
  void *v3; // eax
  void *v5; // [esp+18h] [ebp-B0h]
  const char *s; // [esp+1Ch] [ebp-ACh]
  size_t n; // [esp+2Ch] [ebp-9Ch]
  size_t v8; // [esp+30h] [ebp-98h]
  _BOOL4 v9; // [esp+34h] [ebp-94h]
  char *dest; // [esp+38h] [ebp-90h]

  v5 = (void *)dword_805BC9B;
  if ( !dword_805BC9B )
  {
    s = getenv("CHARSETALIASDIR");
    if ( !s || !*s )
      s = "/home/hwangdz/coreutils/coreutils-8.28/install_m32/lib";
    n = strlen(s);
    v8 = strlen("charset.alias");
    v0 = n && s[n - 1] != 47;
    v9 = v0;
    dest = (char *)malloc(n + v0 + v8 + 1);
    if ( dest )
    {
      memcpy(dest, s, n);
      if ( v9 )
        dest[n] = 47;
      memcpy(&dest[n + v9], "charset.alias", v8 + 1);
    }
    free(0);
    v3 = &loc_805297D;
    if ( dest )
      v3 = &loc_805298C;
    dword_805B174 = (int)v3;
    sub_8055B70(v2, v1);
    v5 = &unk_80575BF;
    dword_805BC9B = (int)&unk_80575BF;
  }
  return v5;
}
// 8055B70: using guessed type int __fastcall sub_8055B70(_DWORD, _DWORD);
// 805B174: using guessed type int dword_805B174;
// 805BC9B: using guessed type int dword_805BC9B;

//----- (08052CF8) --------------------------------------------------------
const char *sub_8052CF8()
{
  char *v0; // ST1C_4
  const char *s1; // [esp+18h] [ebp-10h]
  char *s2; // [esp+1Ch] [ebp-Ch]

  s1 = nl_langinfo(14);
  if ( !s1 )
    s1 = (const char *)&unk_80575BF;
  for ( s2 = (char *)sub_80527B0(); *s2; s2 = &v0[strlen(v0) + 1] )
  {
    if ( !strcmp(s1, s2) || *s2 == 42 && !s2[1] )
    {
      s1 = &s2[strlen(s2) + 1];
      break;
    }
    v0 = &s2[strlen(s2) + 1];
  }
  if ( !*s1 )
    s1 = "ASCII";
  return s1;
}

//----- (08052DAB) --------------------------------------------------------
#error "8052DCB: call analysis failed (funcsize=59)"

//----- (08052E67) --------------------------------------------------------
#error "8053020: positive sp value has been found (funcsize=7)"

//----- (08053161) --------------------------------------------------------
int __cdecl sub_8053161(int a1, int a2, unsigned int a3)
{
  void *v3; // esp
  unsigned int v4; // eax
  bool v5; // zf
  void *v6; // eax
  int v8; // [esp+0h] [ebp-38h]
  int v9; // [esp+4h] [ebp-34h]
  int v10; // [esp+8h] [ebp-30h]
  int v11; // [esp+Ch] [ebp-2Ch]
  int v12; // [esp+10h] [ebp-28h]
  int v13; // [esp+14h] [ebp-24h]
  int v14; // [esp+18h] [ebp-20h]
  int v15; // [esp+1Ch] [ebp-1Ch]
  int v16; // [esp+20h] [ebp-18h]
  int v17; // [esp+24h] [ebp-14h]
  unsigned int v18; // [esp+28h] [ebp-10h]
  unsigned int v19; // [esp+2Ch] [ebp-Ch]
  int v20; // [esp+30h] [ebp-8h]
  int v21; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h]

  v18 = a3;
  if ( a3 > 0x1FFFFFFF )
  {
    v4 = 0;
  }
  else if ( 4 * v18 > 0xFB7 )
  {
    v4 = sub_80552AF(4 * v18);
  }
  else
  {
    v3 = alloca(16 * ((4 * (v18 + 2) + 30) / 0x10));
    v4 = 16 * (((unsigned int)&v12 + 3) >> 4) + 8;
  }
  v19 = v4;
  v5 = v4 == 0;
  v6 = &loc_8053214;
  if ( !v5 )
    v6 = &loc_805321E;
  dword_805B188 = (int)v6;
  sub_8055AF8(v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, savedregs);
  return 0;
}
// 8055AF8: using guessed type int __stdcall sub_8055AF8(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 805B188: using guessed type int dword_805B188;

//----- (080533D9) --------------------------------------------------------
void __cdecl __noreturn sub_80533D9(int a1, const char *a2, int a3)
{
  sub_805557D(a2);
}

//----- (08053BCF) --------------------------------------------------------
_BYTE *__usercall sub_8053BCF@<eax>(int a1@<ebx>, _BYTE *a2, _BYTE *a3)
{
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  _BOOL4 v6; // eax
  int v7; // edx
  int v8; // ecx
  int v9; // edx
  int v10; // ecx
  _BOOL4 v11; // eax
  bool v12; // zf
  void *v13; // eax
  _BYTE *v15; // eax
  int v16; // edx
  unsigned int v17; // eax
  int v18; // eax
  int v19; // edx
  int v20; // ecx
  void *v21; // eax
  void *v22; // eax
  int v23; // [esp-8h] [ebp-180h]
  int v24; // [esp-4h] [ebp-17Ch]
  _BYTE *v25; // [esp+0h] [ebp-178h]
  unsigned int v26; // [esp+4h] [ebp-174h]
  int v27; // [esp+8h] [ebp-170h]
  int *v28; // [esp+Ch] [ebp-16Ch]
  int v29; // [esp+10h] [ebp-168h]
  int v30; // [esp+14h] [ebp-164h]
  _BYTE *v31; // [esp+18h] [ebp-160h]
  _BYTE *v32; // [esp+1Ch] [ebp-15Ch]
  int v33; // [esp+20h] [ebp-158h]
  int v34; // [esp+24h] [ebp-154h]
  int v35; // [esp+28h] [ebp-150h]
  int v36; // [esp+2Ch] [ebp-14Ch]
  int v37; // [esp+30h] [ebp-148h]
  int v38; // [esp+34h] [ebp-144h]
  int v39; // [esp+38h] [ebp-140h]
  unsigned int v40; // [esp+3Ch] [ebp-13Ch]
  unsigned int v41; // [esp+40h] [ebp-138h]
  unsigned int v42; // [esp+44h] [ebp-134h]
  _BYTE *v43; // [esp+48h] [ebp-130h]
  _BYTE *v44; // [esp+4Ch] [ebp-12Ch]
  _BYTE *v45; // [esp+50h] [ebp-128h]
  char v46; // [esp+54h] [ebp-124h]
  int v47; // [esp+58h] [ebp-120h]
  char v48; // [esp+60h] [ebp-118h]
  void *s2; // [esp+64h] [ebp-114h]
  char v50; // [esp+6Ch] [ebp-10Ch]
  int v51; // [esp+70h] [ebp-108h]
  char v52; // [esp+8Ch] [ebp-ECh]
  char v53; // [esp+98h] [ebp-E0h]
  _BYTE *v54; // [esp+9Ch] [ebp-DCh]
  int v55; // [esp+C4h] [ebp-B4h]
  int v56; // [esp+C8h] [ebp-B0h]
  int v57; // [esp+D0h] [ebp-A8h]
  void *s1; // [esp+D4h] [ebp-A4h]
  int v59; // [esp+DCh] [ebp-9Ch]
  int v60; // [esp+E0h] [ebp-98h]
  unsigned int v61; // [esp+16Ch] [ebp-Ch]

  v32 = a2;
  v31 = a3;
  v61 = __readgsdword(0x14u);
  if ( __ctype_get_mb_cur_max() > 1 )
  {
    s2 = v31;
    v46 = 0;
    memset(&v47, 0, 8u);
    v48 = 0;
    sub_8054459(v4, v5, (int)&v46);
    v6 = v50 != 1 || v51;
    if ( !v6 )
      return v32;
    HIBYTE(v33) = 1;
    v36 = 0;
    v37 = 0;
    v38 = 0;
    v54 = v31;
    v52 = 0;
    memset(&v25 - 58, 0, 8u);
    v53 = 0;
    s1 = v32;
    LOBYTE(v55) = 0;
    memset(&v56, 0, 8u);
    LOBYTE(v57) = 0;
    sub_8054459(v7, v8, (int)&v55);
    v11 = (_BYTE)v59 != 1 || v60;
    v12 = v11 == 0;
    v24 = v11;
    v23 = a1;
    v13 = &loc_8053D93;
    if ( !v12 )
      v13 = &loc_8053D9D;
    dword_805B19C = (int)v13;
    sub_8055A8A(
      v10,
      v9,
      v25,
      v26,
      v27,
      v28,
      v29,
      v30,
      v31,
      v32,
      v33,
      v34,
      v35,
      v36,
      v37,
      v38,
      v39,
      v40,
      v41,
      v42,
      v43,
      v44,
      v45,
      *(_DWORD *)&v46,
      v47);
    return 0;
  }
  if ( !*v31 )
    return v32;
  LOBYTE(v34) = 1;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v43 = v31;
  v15 = v31;
  v16 = (int)(v31++ + 1);
  BYTE2(v34) = *v15;
  if ( !*v32 )
    return 0;
  if ( (_BYTE)v34 )
  {
    if ( v40 > 9 )
    {
      v16 = v40;
      if ( 5 * v40 <= v41 )
      {
        if ( v43 )
        {
          v26 = v41 - v42;
          v25 = v43;
          v43 += strnlen();
          if ( !*v43 )
            v43 = 0;
          v42 = v41;
        }
        if ( !v43 )
        {
          v17 = strlen(v31 - 1);
          v28 = &v35;
          v18 = sub_8053161((int)v32, (int)(v31 - 1), v17);
          HIBYTE(v34) = v18;
          v12 = (_BYTE)v18 == 0;
          v24 = v18;
          v23 = a1;
          v21 = &loc_805433F;
          if ( v12 )
            v21 = &loc_805434A;
          dword_805B19C = (int)v21;
          sub_8055A8A(
            v20,
            v19,
            v25,
            v26,
            v27,
            v28,
            v29,
            v30,
            v31,
            v32,
            v33,
            v34,
            v35,
            v36,
            v37,
            v38,
            v39,
            v40,
            v41,
            v42,
            v43,
            v44,
            v45,
            *(_DWORD *)&v46,
            v47);
          return (_BYTE *)v35;
        }
      }
    }
  }
  ++v40;
  ++v41;
  if ( *v32 != BYTE2(v34) )
  {
    dword_805B188 = (int)&loc_8054236;
    sub_8055AF8(v25, v26, v27, v28, v29, v30, v31, v32 + 1, v33, v34, v35, v36, v37, v38, v39);
    return v32;
  }
  v44 = v32 + 1;
  v45 = v31;
  if ( !*v31 )
    return v32;
  v12 = *v44 == 0;
  v24 = (unsigned __int8)*v44;
  v23 = a1;
  v22 = &loc_80543CD;
  if ( !v12 )
    v22 = &loc_80543D4;
  dword_805B174 = (int)v22;
  sub_8055B70(v3, v16);
  return 0;
}
// 80493D0: using guessed type int strnlen(void);
// 8055A8A: using guessed type int __fastcall sub_8055A8A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8055AF8: using guessed type int __stdcall sub_8055AF8(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8055B70: using guessed type int __fastcall sub_8055B70(_DWORD, _DWORD);
// 805B174: using guessed type int dword_805B174;
// 805B188: using guessed type int dword_805B188;
// 805B19C: using guessed type int dword_805B19C;

//----- (08054459) --------------------------------------------------------
int __usercall sub_8054459@<eax>(int a1@<edx>, int a2@<ecx>, int a3)
{
  int result; // eax
  void *v4; // eax
  size_t v5; // eax
  size_t v6; // eax

  result = *(unsigned __int8 *)(a3 + 12);
  if ( !(_BYTE)result )
  {
    v4 = &loc_8054493;
    if ( !*(_BYTE *)a3 )
      v4 = &loc_8054498;
    dword_805B174 = (int)v4;
    sub_8055B70(a2, a1);
    v5 = __ctype_get_mb_cur_max();
    v6 = sub_805501E(*(void **)(a3 + 16), v5);
    *(_DWORD *)(a3 + 20) = sub_80525B3((wchar_t *)(a3 + 28), *(char **)(a3 + 16), v6, (mbstate_t *)(a3 + 4));
    if ( *(_DWORD *)(a3 + 20) == -1 )
    {
      *(_DWORD *)(a3 + 20) = 1;
      *(_BYTE *)(a3 + 24) = 0;
    }
    else if ( *(_DWORD *)(a3 + 20) == -2 )
    {
      *(_DWORD *)(a3 + 20) = strlen(*(const char **)(a3 + 16));
      *(_BYTE *)(a3 + 24) = 0;
    }
    else
    {
      if ( !*(_DWORD *)(a3 + 20) )
      {
        *(_DWORD *)(a3 + 20) = 1;
        if ( **(_BYTE **)(a3 + 16) )
          __assert_fail("*iter->cur.ptr == '\\0'", "lib/mbuiter.h", 0xB2u, "mbuiter_multi_next");
        if ( *(_DWORD *)(a3 + 28) )
          __assert_fail("iter->cur.wc == 0", "lib/mbuiter.h", 0xB3u, "mbuiter_multi_next");
      }
      *(_BYTE *)(a3 + 24) = 1;
      if ( mbsinit((const mbstate_t *)(a3 + 4)) )
        *(_BYTE *)a3 = 0;
    }
    result = a3;
    *(_BYTE *)(a3 + 12) = 1;
  }
  return result;
}
// 8055B70: using guessed type int __fastcall sub_8055B70(_DWORD, _DWORD);
// 805B174: using guessed type int dword_805B174;

//----- (08054743) --------------------------------------------------------
#error "80547C7: call analysis failed (funcsize=31)"

//----- (080547CC) --------------------------------------------------------
#error "8054BE3: positive sp value has been found (funcsize=204)"

//----- (08054BE4) --------------------------------------------------------
void *__cdecl sub_8054BE4(char *s, iconv_t cd)
{
  void *result; // eax
  char *v3; // eax
  int v4; // [esp+0h] [ebp-78h]
  char *inbuf; // [esp+28h] [ebp-50h]
  size_t inbytesleft; // [esp+2Ch] [ebp-4Ch]
  char *outbuf; // [esp+30h] [ebp-48h]
  size_t outbytesleft; // [esp+34h] [ebp-44h]
  void *ptr; // [esp+38h] [ebp-40h]
  size_t size; // [esp+3Ch] [ebp-3Ch]
  int v11; // [esp+40h] [ebp-38h]
  size_t v12; // [esp+44h] [ebp-34h]
  int v13; // [esp+48h] [ebp-30h]
  size_t v14; // [esp+4Ch] [ebp-2Ch]
  char *v15; // [esp+50h] [ebp-28h]
  size_t v16; // [esp+54h] [ebp-24h]
  int v17; // [esp+58h] [ebp-20h]
  size_t v18; // [esp+5Ch] [ebp-1Ch]
  char *v19; // [esp+60h] [ebp-18h]
  size_t v20; // [esp+64h] [ebp-14h]
  void *v21; // [esp+68h] [ebp-10h]
  int v22; // [esp+6Ch] [ebp-Ch]

  inbuf = s;
  inbytesleft = strlen(s);
  size = inbytesleft;
  v11 = 0xFFFF;
  if ( inbytesleft <= 0xFFF )
    size *= 16;
  ptr = malloc(++size);
  if ( ptr )
  {
    iconv(cd, 0, 0, 0, 0);
    outbuf = (char *)ptr;
    for ( outbytesleft = size - 1; ; outbytesleft = v14 - v13 - 1 )
    {
      v12 = iconv(cd, (char **)&v4 - 20, &inbytesleft, &outbuf, &outbytesleft);
      if ( v12 != -1 || *__errno_location() == 22 )
        break;
      if ( *__errno_location() != 7 )
        goto LABEL_25;
      v13 = outbuf - (_BYTE *)ptr;
      v14 = 2 * size;
      if ( 2 * size <= size )
      {
        *__errno_location() = 12;
LABEL_25:
        v22 = *__errno_location();
        free(ptr);
        *__errno_location() = v22;
        return 0;
      }
      v15 = (char *)realloc(ptr, v14);
      if ( !v15 )
      {
        *__errno_location() = 12;
        goto LABEL_25;
      }
      ptr = v15;
      size = v14;
      outbuf = &v15[v13];
    }
    while ( 1 )
    {
      v16 = iconv(cd, 0, 0, &outbuf, &outbytesleft);
      if ( v16 != -1 )
        break;
      if ( *__errno_location() != 7 )
        goto LABEL_25;
      v17 = outbuf - (_BYTE *)ptr;
      v18 = 2 * size;
      if ( 2 * size <= size )
      {
        *__errno_location() = 12;
        goto LABEL_25;
      }
      v19 = (char *)realloc(ptr, v18);
      if ( !v19 )
      {
        *__errno_location() = 12;
        goto LABEL_25;
      }
      ptr = v19;
      size = v18;
      outbuf = &v19[v17];
      outbytesleft = v18 - v17 - 1;
    }
    v3 = outbuf++;
    *v3 = 0;
    v20 = outbuf - (_BYTE *)ptr;
    if ( outbuf - (_BYTE *)ptr < size )
    {
      v21 = realloc(ptr, v20);
      if ( v21 )
        ptr = v21;
    }
    result = ptr;
  }
  else
  {
    *__errno_location() = 12;
    result = 0;
  }
  return result;
}

//----- (08054F1D) --------------------------------------------------------
#error "8054FBE: call analysis failed (funcsize=63)"

//----- (0805501E) --------------------------------------------------------
size_t __cdecl sub_805501E(void *s, size_t n)
{
  size_t result; // eax
  _BYTE *v3; // [esp+1Ch] [ebp-Ch]

  v3 = memchr(s, 0, n);
  if ( v3 )
    result = v3 - (_BYTE *)s + 1;
  else
    result = n;
  return result;
}

//----- (08055279) --------------------------------------------------------
int __cdecl sub_8055279(int a1)
{
  int result; // eax

  if ( (unsigned int)(a1 - 65) > 0x19 )
    result = a1;
  else
    result = a1 + 32;
  return result;
}

//----- (080552AF) --------------------------------------------------------
unsigned int __cdecl sub_80552AF(unsigned int a1)
{
  _DWORD *v1; // ST18_4
  unsigned int v2; // ST14_4
  _DWORD *v4; // [esp+14h] [ebp-14h]

  if ( a1 + 8 < a1 )
    return 0;
  v4 = malloc(a1 + 8);
  if ( !v4 )
    return 0;
  v1 = v4;
  v2 = (unsigned int)(v4 + 2);
  v1[1] = 336984906;
  *v1 = dword_805BCBB[v2 % 0x101];
  dword_805BCBB[v2 % 0x101] = v2;
  return v2;
}

//----- (08055364) --------------------------------------------------------
#error "8055397: call analysis failed (funcsize=72)"

//----- (08055471) --------------------------------------------------------
#error "80554C1: call analysis failed (funcsize=54)"

//----- (08055516) --------------------------------------------------------
bool __cdecl sub_8055516(unsigned __int8 a1)
{
  return (((unsigned int)dword_8057780[a1 >> 5] >> (a1 & 0x1F)) & 1) != 0;
}

//----- (0805557D) --------------------------------------------------------
int __cdecl __noreturn sub_805557D(const char *a1)
{
  int v1; // edx
  int v2; // ecx
  int v3; // ST08_4
  int v4; // ST0C_4
  int v5; // ST10_4
  int v6; // ST18_4
  int v7; // edx
  int v8; // ecx
  _BOOL4 v9; // eax
  bool v10; // zf
  void *v11; // eax
  int v12; // edx
  int v13; // ecx
  unsigned int v14; // et1
  int (*v15)(); // eax
  int v17; // [esp+0h] [ebp-58h]
  int v18; // [esp+4h] [ebp-54h]
  int v19; // [esp+8h] [ebp-50h]
  char *s; // [esp+Ch] [ebp-4Ch]
  int v21; // [esp+10h] [ebp-48h]
  char v22; // [esp+14h] [ebp-44h]
  int v23; // [esp+18h] [ebp-40h]
  int v24; // [esp+1Ch] [ebp-3Ch]
  char v25; // [esp+20h] [ebp-38h]
  const char *v26; // [esp+24h] [ebp-34h]
  int v27; // [esp+28h] [ebp-30h]
  int v28; // [esp+2Ch] [ebp-2Ch]
  int v29; // [esp+30h] [ebp-28h]
  int v30; // [esp+34h] [ebp-24h]
  int v31; // [esp+38h] [ebp-20h]
  int v32; // [esp+3Ch] [ebp-1Ch]
  int v33; // [esp+40h] [ebp-18h]
  int v34; // [esp+44h] [ebp-14h]
  int v35; // [esp+48h] [ebp-10h]
  unsigned int v36; // [esp+4Ch] [ebp-Ch]
  int v37; // [esp+50h] [ebp-8h]
  int v38; // [esp+54h] [ebp-4h]
  int savedregs; // [esp+58h] [ebp+0h]

  v36 = __readgsdword(0x14u);
  if ( __ctype_get_mb_cur_max() <= 1 )
  {
    strlen(a1);
  }
  else
  {
    v26 = a1;
    v22 = 0;
    memset(&v23, 0, 8u);
    v25 = 0;
    dword_805B19C = (int)&loc_80555FF;
    sub_8055A8A(
      v2,
      v1,
      v3,
      v4,
      v5,
      a1,
      0,
      *(_DWORD *)&v22,
      v23,
      v24,
      *(_DWORD *)&v25,
      v26,
      v27,
      v28,
      v29,
      v30,
      v31,
      v32,
      v33,
      v34,
      v35,
      v36,
      v37,
      v38,
      savedregs);
    v21 = v6 + 1;
    v7 = (int)v26;
    v26 += v27;
    v25 = 0;
    sub_8054459(v7, v8, (int)&v22);
    v9 = (_BYTE)v28 != 1 || v29;
    v10 = v9 == 0;
    v11 = &loc_8055645;
    if ( !v10 )
      v11 = &loc_80555EC;
    dword_805B188 = (int)v11;
    sub_8055AF8(v17, v18, v19, s, v21, *(_DWORD *)&v22, v23, v24, *(_DWORD *)&v25, v26, v27, v28, v29, v30, v31);
  }
  v14 = __readgsdword(0x14u);
  v13 = v14 ^ v36;
  v15 = (int (*)())&loc_805567A;
  if ( v14 == v36 )
    v15 = sub_805567F;
  dword_805B174 = (int)v15;
  return sub_8055B70(v13, v12);
}
// 805557D: could not find valid save-restore pair for ebx
// 805567F: using guessed type int sub_805567F();
// 8055A8A: using guessed type int __fastcall sub_8055A8A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8055AF8: using guessed type int __stdcall sub_8055AF8(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8055B70: using guessed type int __fastcall sub_8055B70(_DWORD, _DWORD);
// 805B174: using guessed type int dword_805B174;
// 805B188: using guessed type int dword_805B188;
// 805B19C: using guessed type int dword_805B19C;

//----- (0805567F) --------------------------------------------------------
#error "8055680: positive sp value has been found (funcsize=0)"

//----- (0805568B) --------------------------------------------------------
#error "8055731: call analysis failed (funcsize=152)"

//----- (080558D5) --------------------------------------------------------
int __cdecl sub_80558D5(int a1)
{
  return __cxa_atexit(a1, 0, dword_805B1CC);
}
// 80491F0: using guessed type int __cdecl __cxa_atexit(_DWORD, _DWORD, _DWORD);
// 805B1CC: using guessed type int dword_805B1CC;

//----- (08055904) --------------------------------------------------------
int __cdecl sub_8055904(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8049190: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (08055A8A) --------------------------------------------------------
#error "8055A90: positive sp value has been found (funcsize=0)"

//----- (08055AF8) --------------------------------------------------------
#error "8055AFE: positive sp value has been found (funcsize=0)"

//----- (08055B70) --------------------------------------------------------
#error "8055B76: positive sp value has been found (funcsize=0)"

//----- (08055BDC) --------------------------------------------------------
#error "8055BE2: positive sp value has been found (funcsize=0)"

//----- (08055BF0) --------------------------------------------------------
int (**sub_8055BF0())()
{
  int (**result)(); // eax
  int v1; // esi
  int v2; // edi

  init_proc();
  result = off_805AEEC;
  v1 = &off_805AEF0 - off_805AEEC;
  if ( v1 )
  {
    v2 = 0;
    do
      result = (int (**)())off_805AEEC[v2++]();
    while ( v1 != v2 );
  }
  return result;
}
// 805AEEC: using guessed type int (*off_805AEEC[2])();
// 805AEF0: using guessed type int (*off_805AEF0)();

//----- (08055C54) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 49 decompilation failure(s) on 152 function(s)"
